var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Sole","category":"page"},{"location":"#Sole","page":"Home","title":"Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for Sole, a Julia package for symbolic AI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Sole, Sole.SoleLogics, Sole.SoleData, Sole.SoleModels]","category":"page"},{"location":"#SoleLogics.:¬","page":"Home","title":"SoleLogics.:¬","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.:→","page":"Home","title":"SoleLogics.:→","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.:∧","page":"Home","title":"SoleLogics.:∧","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.:∨","page":"Home","title":"SoleLogics.:∨","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.BASE_CONNECTIVES","page":"Home","title":"SoleLogics.BASE_CONNECTIVES","text":"const BASE_CONNECTIVES = [¬, ∧, ∨, →]\n\nBasic logical operators.\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.BASE_PARSABLE_CONNECTIVES","page":"Home","title":"SoleLogics.BASE_PARSABLE_CONNECTIVES","text":"const BASE_PARSABLE_CONNECTIVES = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]\n\nVector of (standard) operators that are automatically taken care of when parsing. These are ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤ and ⊥.\n\nSee also parseformula.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.BOT","page":"Home","title":"SoleLogics.BOT","text":"const BOT = BooleanTruth(false)\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.BOX","page":"Home","title":"SoleLogics.BOX","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box connective, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_E","page":"Home","title":"SoleLogics.CL_E","text":"Relation leading to the closest eastern Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_N","page":"Home","title":"SoleLogics.CL_N","text":"Relation leading to the closest northern Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_NE","page":"Home","title":"SoleLogics.CL_NE","text":"Relation leading to the closest north-eastern Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_NW","page":"Home","title":"SoleLogics.CL_NW","text":"Relation leading to the closest north-western Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_S","page":"Home","title":"SoleLogics.CL_S","text":"Relation leading to the closest southern Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_SE","page":"Home","title":"SoleLogics.CL_SE","text":"Relation leading to the closest south-eastern Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_SW","page":"Home","title":"SoleLogics.CL_SW","text":"Relation leading to the closest south-western Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CL_W","page":"Home","title":"SoleLogics.CL_W","text":"Relation leading to the closest western Point2D.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.CONJUNCTION","page":"Home","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.DIAMOND","page":"Home","title":"SoleLogics.DIAMOND","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::typeof(◊)) = true\narity(::typeof(◊)) = 1\n\nLogical diamond connective, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.DISJUNCTION","page":"Home","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA2DRelations","page":"Home","title":"SoleLogics.IA2DRelations","text":"(12+1)^2-1=168 2D Interval Algebra relations.\n\nSee RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA2DRelations_extended","page":"Home","title":"SoleLogics.IA2DRelations_extended","text":"(12+1+1)^2-1=195 2D Interval Algebra relations extended with their combinations with the global relation.\n\nSee RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA2D_URelations","page":"Home","title":"SoleLogics.IA2D_URelations","text":"(1+1)*13=26 2D Interval Algebra relations with either globalrel and/or identity.\n\nSee RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA32DRelations","page":"Home","title":"SoleLogics.IA32DRelations","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3Relations","page":"Home","title":"SoleLogics.IA3Relations","text":"const IA3Relations = [IA_I, IA_L, IA_Li]\n\nVector of 3 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA7Relations, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_II","page":"Home","title":"SoleLogics.IA3_II","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_IId","page":"Home","title":"SoleLogics.IA3_IId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_IL","page":"Home","title":"SoleLogics.IA3_IL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_ILi","page":"Home","title":"SoleLogics.IA3_ILi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_IdI","page":"Home","title":"SoleLogics.IA3_IdI","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_IdL","page":"Home","title":"SoleLogics.IA3_IdL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_IdLi","page":"Home","title":"SoleLogics.IA3_IdLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LI","page":"Home","title":"SoleLogics.IA3_LI","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LId","page":"Home","title":"SoleLogics.IA3_LId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LL","page":"Home","title":"SoleLogics.IA3_LL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LLi","page":"Home","title":"SoleLogics.IA3_LLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LiI","page":"Home","title":"SoleLogics.IA3_LiI","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LiId","page":"Home","title":"SoleLogics.IA3_LiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LiL","page":"Home","title":"SoleLogics.IA3_LiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA3_LiLi","page":"Home","title":"SoleLogics.IA3_LiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA72DRelations","page":"Home","title":"SoleLogics.IA72DRelations","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7Relations","page":"Home","title":"SoleLogics.IA7Relations","text":"const IA7Relations = [IA_AorO,   IA_L,  IA_DorBorE,\n                      IA_AiorOi, IA_Li, IA_DiorBiorEi]\n\nVector of 7 interval relations from a coarser version of Allen's interval algebra.\n\nSee also IARelations, IA3Relations, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiAiorOi","page":"Home","title":"SoleLogics.IA7_AiorOiAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiAorO","page":"Home","title":"SoleLogics.IA7_AiorOiAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiDiorBiorEi","page":"Home","title":"SoleLogics.IA7_AiorOiDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiDorBorE","page":"Home","title":"SoleLogics.IA7_AiorOiDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiId","page":"Home","title":"SoleLogics.IA7_AiorOiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiL","page":"Home","title":"SoleLogics.IA7_AiorOiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AiorOiLi","page":"Home","title":"SoleLogics.IA7_AiorOiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorOAi","page":"Home","title":"SoleLogics.IA7_AorOAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorOAorO","page":"Home","title":"SoleLogics.IA7_AorOAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorODiorBiorEi","page":"Home","title":"SoleLogics.IA7_AorODiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorODorBorE","page":"Home","title":"SoleLogics.IA7_AorODorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorOId","page":"Home","title":"SoleLogics.IA7_AorOId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorOL","page":"Home","title":"SoleLogics.IA7_AorOL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_AorOLi","page":"Home","title":"SoleLogics.IA7_AorOLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiAiorOi","page":"Home","title":"SoleLogics.IA7_DiorBiorEiAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiAorO","page":"Home","title":"SoleLogics.IA7_DiorBiorEiAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiDiorBiorEi","page":"Home","title":"SoleLogics.IA7_DiorBiorEiDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiDorBorE","page":"Home","title":"SoleLogics.IA7_DiorBiorEiDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiId","page":"Home","title":"SoleLogics.IA7_DiorBiorEiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiL","page":"Home","title":"SoleLogics.IA7_DiorBiorEiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DiorBiorEiLi","page":"Home","title":"SoleLogics.IA7_DiorBiorEiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEAiorOi","page":"Home","title":"SoleLogics.IA7_DorBorEAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEAorO","page":"Home","title":"SoleLogics.IA7_DorBorEAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEDiorBiorEi","page":"Home","title":"SoleLogics.IA7_DorBorEDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEDorBorE","page":"Home","title":"SoleLogics.IA7_DorBorEDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEId","page":"Home","title":"SoleLogics.IA7_DorBorEId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorEL","page":"Home","title":"SoleLogics.IA7_DorBorEL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_DorBorELi","page":"Home","title":"SoleLogics.IA7_DorBorELi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdAiorOi","page":"Home","title":"SoleLogics.IA7_IdAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdAorO","page":"Home","title":"SoleLogics.IA7_IdAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdDiorBiorEi","page":"Home","title":"SoleLogics.IA7_IdDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdDorBorE","page":"Home","title":"SoleLogics.IA7_IdDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdL","page":"Home","title":"SoleLogics.IA7_IdL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_IdLi","page":"Home","title":"SoleLogics.IA7_IdLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LAiorOi","page":"Home","title":"SoleLogics.IA7_LAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LAorO","page":"Home","title":"SoleLogics.IA7_LAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LDiorBiorEi","page":"Home","title":"SoleLogics.IA7_LDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LDorBorE","page":"Home","title":"SoleLogics.IA7_LDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LId","page":"Home","title":"SoleLogics.IA7_LId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LL","page":"Home","title":"SoleLogics.IA7_LL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LLi","page":"Home","title":"SoleLogics.IA7_LLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiAiorOi","page":"Home","title":"SoleLogics.IA7_LiAiorOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiAorO","page":"Home","title":"SoleLogics.IA7_LiAorO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiDiorBiorEi","page":"Home","title":"SoleLogics.IA7_LiDiorBiorEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiDorBorE","page":"Home","title":"SoleLogics.IA7_LiDorBorE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiId","page":"Home","title":"SoleLogics.IA7_LiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiL","page":"Home","title":"SoleLogics.IA7_LiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA7_LiLi","page":"Home","title":"SoleLogics.IA7_LiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IABase","page":"Home","title":"SoleLogics.IABase","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\njulia> length(IA2DRelations)\n168\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.IARelations","page":"Home","title":"SoleLogics.IARelations","text":"const IARelations = [IA_A,  IA_L,  IA_B,  IA_E,  IA_D,  IA_O,\n                     IA_Ai, IA_Li, IA_Bi, IA_Ei, IA_Di, IA_Oi]\n\nVector of the 12 interval relations from Allen's interval algebra.\n\nSee also IA7Relations, IA3Relations, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IARelations_extended","page":"Home","title":"SoleLogics.IARelations_extended","text":"const IARelations_extended = [globalrel, IARelations...]\n\n13 Interval Algebra extended with the global relation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_A","page":"Home","title":"SoleLogics.IA_A","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AA","page":"Home","title":"SoleLogics.IA_AA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AAi","page":"Home","title":"SoleLogics.IA_AAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AB","page":"Home","title":"SoleLogics.IA_AB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ABi","page":"Home","title":"SoleLogics.IA_ABi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AD","page":"Home","title":"SoleLogics.IA_AD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ADi","page":"Home","title":"SoleLogics.IA_ADi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AE","page":"Home","title":"SoleLogics.IA_AE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AEi","page":"Home","title":"SoleLogics.IA_AEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AId","page":"Home","title":"SoleLogics.IA_AId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AL","page":"Home","title":"SoleLogics.IA_AL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ALi","page":"Home","title":"SoleLogics.IA_ALi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AO","page":"Home","title":"SoleLogics.IA_AO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AOi","page":"Home","title":"SoleLogics.IA_AOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AU","page":"Home","title":"SoleLogics.IA_AU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Ai","page":"Home","title":"SoleLogics.IA_Ai","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiA","page":"Home","title":"SoleLogics.IA_AiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiAi","page":"Home","title":"SoleLogics.IA_AiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiB","page":"Home","title":"SoleLogics.IA_AiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiBi","page":"Home","title":"SoleLogics.IA_AiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiD","page":"Home","title":"SoleLogics.IA_AiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiDi","page":"Home","title":"SoleLogics.IA_AiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiE","page":"Home","title":"SoleLogics.IA_AiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiEi","page":"Home","title":"SoleLogics.IA_AiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiId","page":"Home","title":"SoleLogics.IA_AiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiL","page":"Home","title":"SoleLogics.IA_AiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiLi","page":"Home","title":"SoleLogics.IA_AiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiO","page":"Home","title":"SoleLogics.IA_AiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiOi","page":"Home","title":"SoleLogics.IA_AiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiU","page":"Home","title":"SoleLogics.IA_AiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AiorOi","page":"Home","title":"SoleLogics.IA_AiorOi","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_AorO","page":"Home","title":"SoleLogics.IA_AorO","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_B","page":"Home","title":"SoleLogics.IA_B","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BA","page":"Home","title":"SoleLogics.IA_BA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BAi","page":"Home","title":"SoleLogics.IA_BAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BB","page":"Home","title":"SoleLogics.IA_BB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BBi","page":"Home","title":"SoleLogics.IA_BBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BD","page":"Home","title":"SoleLogics.IA_BD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BDi","page":"Home","title":"SoleLogics.IA_BDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BE","page":"Home","title":"SoleLogics.IA_BE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BEi","page":"Home","title":"SoleLogics.IA_BEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BId","page":"Home","title":"SoleLogics.IA_BId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BL","page":"Home","title":"SoleLogics.IA_BL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BLi","page":"Home","title":"SoleLogics.IA_BLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BO","page":"Home","title":"SoleLogics.IA_BO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BOi","page":"Home","title":"SoleLogics.IA_BOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BU","page":"Home","title":"SoleLogics.IA_BU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Bi","page":"Home","title":"SoleLogics.IA_Bi","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiA","page":"Home","title":"SoleLogics.IA_BiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiAi","page":"Home","title":"SoleLogics.IA_BiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiB","page":"Home","title":"SoleLogics.IA_BiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiBi","page":"Home","title":"SoleLogics.IA_BiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiD","page":"Home","title":"SoleLogics.IA_BiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiDi","page":"Home","title":"SoleLogics.IA_BiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiE","page":"Home","title":"SoleLogics.IA_BiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiEi","page":"Home","title":"SoleLogics.IA_BiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiId","page":"Home","title":"SoleLogics.IA_BiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiL","page":"Home","title":"SoleLogics.IA_BiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiLi","page":"Home","title":"SoleLogics.IA_BiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiO","page":"Home","title":"SoleLogics.IA_BiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiOi","page":"Home","title":"SoleLogics.IA_BiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_BiU","page":"Home","title":"SoleLogics.IA_BiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_D","page":"Home","title":"SoleLogics.IA_D","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DA","page":"Home","title":"SoleLogics.IA_DA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DAi","page":"Home","title":"SoleLogics.IA_DAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DB","page":"Home","title":"SoleLogics.IA_DB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DBi","page":"Home","title":"SoleLogics.IA_DBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DD","page":"Home","title":"SoleLogics.IA_DD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DDi","page":"Home","title":"SoleLogics.IA_DDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DE","page":"Home","title":"SoleLogics.IA_DE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DEi","page":"Home","title":"SoleLogics.IA_DEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DId","page":"Home","title":"SoleLogics.IA_DId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DL","page":"Home","title":"SoleLogics.IA_DL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DLi","page":"Home","title":"SoleLogics.IA_DLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DO","page":"Home","title":"SoleLogics.IA_DO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DOi","page":"Home","title":"SoleLogics.IA_DOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DU","page":"Home","title":"SoleLogics.IA_DU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Di","page":"Home","title":"SoleLogics.IA_Di","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiA","page":"Home","title":"SoleLogics.IA_DiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiAi","page":"Home","title":"SoleLogics.IA_DiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiB","page":"Home","title":"SoleLogics.IA_DiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiBi","page":"Home","title":"SoleLogics.IA_DiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiD","page":"Home","title":"SoleLogics.IA_DiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiDi","page":"Home","title":"SoleLogics.IA_DiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiE","page":"Home","title":"SoleLogics.IA_DiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiEi","page":"Home","title":"SoleLogics.IA_DiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiId","page":"Home","title":"SoleLogics.IA_DiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiL","page":"Home","title":"SoleLogics.IA_DiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiLi","page":"Home","title":"SoleLogics.IA_DiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiO","page":"Home","title":"SoleLogics.IA_DiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiOi","page":"Home","title":"SoleLogics.IA_DiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiU","page":"Home","title":"SoleLogics.IA_DiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DiorBiorEi","page":"Home","title":"SoleLogics.IA_DiorBiorEi","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_DorBorE","page":"Home","title":"SoleLogics.IA_DorBorE","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_E","page":"Home","title":"SoleLogics.IA_E","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EA","page":"Home","title":"SoleLogics.IA_EA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EAi","page":"Home","title":"SoleLogics.IA_EAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EB","page":"Home","title":"SoleLogics.IA_EB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EBi","page":"Home","title":"SoleLogics.IA_EBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ED","page":"Home","title":"SoleLogics.IA_ED","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EDi","page":"Home","title":"SoleLogics.IA_EDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EE","page":"Home","title":"SoleLogics.IA_EE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EEi","page":"Home","title":"SoleLogics.IA_EEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EId","page":"Home","title":"SoleLogics.IA_EId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EL","page":"Home","title":"SoleLogics.IA_EL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ELi","page":"Home","title":"SoleLogics.IA_ELi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EO","page":"Home","title":"SoleLogics.IA_EO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EOi","page":"Home","title":"SoleLogics.IA_EOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EU","page":"Home","title":"SoleLogics.IA_EU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Ei","page":"Home","title":"SoleLogics.IA_Ei","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiA","page":"Home","title":"SoleLogics.IA_EiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiAi","page":"Home","title":"SoleLogics.IA_EiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiB","page":"Home","title":"SoleLogics.IA_EiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiBi","page":"Home","title":"SoleLogics.IA_EiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiD","page":"Home","title":"SoleLogics.IA_EiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiDi","page":"Home","title":"SoleLogics.IA_EiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiE","page":"Home","title":"SoleLogics.IA_EiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiEi","page":"Home","title":"SoleLogics.IA_EiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiId","page":"Home","title":"SoleLogics.IA_EiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiL","page":"Home","title":"SoleLogics.IA_EiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiLi","page":"Home","title":"SoleLogics.IA_EiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiO","page":"Home","title":"SoleLogics.IA_EiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiOi","page":"Home","title":"SoleLogics.IA_EiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_EiU","page":"Home","title":"SoleLogics.IA_EiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_I","page":"Home","title":"SoleLogics.IA_I","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdA","page":"Home","title":"SoleLogics.IA_IdA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdAi","page":"Home","title":"SoleLogics.IA_IdAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdB","page":"Home","title":"SoleLogics.IA_IdB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdBi","page":"Home","title":"SoleLogics.IA_IdBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdD","page":"Home","title":"SoleLogics.IA_IdD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdDi","page":"Home","title":"SoleLogics.IA_IdDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdE","page":"Home","title":"SoleLogics.IA_IdE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdEi","page":"Home","title":"SoleLogics.IA_IdEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdL","page":"Home","title":"SoleLogics.IA_IdL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdLi","page":"Home","title":"SoleLogics.IA_IdLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdO","page":"Home","title":"SoleLogics.IA_IdO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdOi","page":"Home","title":"SoleLogics.IA_IdOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_IdU","page":"Home","title":"SoleLogics.IA_IdU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_L","page":"Home","title":"SoleLogics.IA_L","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LA","page":"Home","title":"SoleLogics.IA_LA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LAi","page":"Home","title":"SoleLogics.IA_LAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LB","page":"Home","title":"SoleLogics.IA_LB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LBi","page":"Home","title":"SoleLogics.IA_LBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LD","page":"Home","title":"SoleLogics.IA_LD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LDi","page":"Home","title":"SoleLogics.IA_LDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LE","page":"Home","title":"SoleLogics.IA_LE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LEi","page":"Home","title":"SoleLogics.IA_LEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LId","page":"Home","title":"SoleLogics.IA_LId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LL","page":"Home","title":"SoleLogics.IA_LL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LLi","page":"Home","title":"SoleLogics.IA_LLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LO","page":"Home","title":"SoleLogics.IA_LO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LOi","page":"Home","title":"SoleLogics.IA_LOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LU","page":"Home","title":"SoleLogics.IA_LU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Li","page":"Home","title":"SoleLogics.IA_Li","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiA","page":"Home","title":"SoleLogics.IA_LiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiAi","page":"Home","title":"SoleLogics.IA_LiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiB","page":"Home","title":"SoleLogics.IA_LiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiBi","page":"Home","title":"SoleLogics.IA_LiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiD","page":"Home","title":"SoleLogics.IA_LiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiDi","page":"Home","title":"SoleLogics.IA_LiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiE","page":"Home","title":"SoleLogics.IA_LiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiEi","page":"Home","title":"SoleLogics.IA_LiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiId","page":"Home","title":"SoleLogics.IA_LiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiL","page":"Home","title":"SoleLogics.IA_LiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiLi","page":"Home","title":"SoleLogics.IA_LiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiO","page":"Home","title":"SoleLogics.IA_LiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiOi","page":"Home","title":"SoleLogics.IA_LiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_LiU","page":"Home","title":"SoleLogics.IA_LiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_O","page":"Home","title":"SoleLogics.IA_O","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OA","page":"Home","title":"SoleLogics.IA_OA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OAi","page":"Home","title":"SoleLogics.IA_OAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OB","page":"Home","title":"SoleLogics.IA_OB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OBi","page":"Home","title":"SoleLogics.IA_OBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OD","page":"Home","title":"SoleLogics.IA_OD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ODi","page":"Home","title":"SoleLogics.IA_ODi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OE","page":"Home","title":"SoleLogics.IA_OE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OEi","page":"Home","title":"SoleLogics.IA_OEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OId","page":"Home","title":"SoleLogics.IA_OId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OL","page":"Home","title":"SoleLogics.IA_OL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OLi","page":"Home","title":"SoleLogics.IA_OLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OO","page":"Home","title":"SoleLogics.IA_OO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OOi","page":"Home","title":"SoleLogics.IA_OOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OU","page":"Home","title":"SoleLogics.IA_OU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_Oi","page":"Home","title":"SoleLogics.IA_Oi","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiA","page":"Home","title":"SoleLogics.IA_OiA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiAi","page":"Home","title":"SoleLogics.IA_OiAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiB","page":"Home","title":"SoleLogics.IA_OiB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiBi","page":"Home","title":"SoleLogics.IA_OiBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiD","page":"Home","title":"SoleLogics.IA_OiD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiDi","page":"Home","title":"SoleLogics.IA_OiDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiE","page":"Home","title":"SoleLogics.IA_OiE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiEi","page":"Home","title":"SoleLogics.IA_OiEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiId","page":"Home","title":"SoleLogics.IA_OiId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiL","page":"Home","title":"SoleLogics.IA_OiL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiLi","page":"Home","title":"SoleLogics.IA_OiLi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiO","page":"Home","title":"SoleLogics.IA_OiO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiOi","page":"Home","title":"SoleLogics.IA_OiOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_OiU","page":"Home","title":"SoleLogics.IA_OiU","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UA","page":"Home","title":"SoleLogics.IA_UA","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UAi","page":"Home","title":"SoleLogics.IA_UAi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UB","page":"Home","title":"SoleLogics.IA_UB","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UBi","page":"Home","title":"SoleLogics.IA_UBi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UD","page":"Home","title":"SoleLogics.IA_UD","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UDi","page":"Home","title":"SoleLogics.IA_UDi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UE","page":"Home","title":"SoleLogics.IA_UE","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UEi","page":"Home","title":"SoleLogics.IA_UEi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UId","page":"Home","title":"SoleLogics.IA_UId","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UL","page":"Home","title":"SoleLogics.IA_UL","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_ULi","page":"Home","title":"SoleLogics.IA_ULi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UO","page":"Home","title":"SoleLogics.IA_UO","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IA_UOi","page":"Home","title":"SoleLogics.IA_UOi","text":"See RectangleRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.IMPLICATION","page":"Home","title":"SoleLogics.IMPLICATION","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.NEGATION","page":"Home","title":"SoleLogics.NEGATION","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.Operator","page":"Home","title":"SoleLogics.Operator","text":"const Operator = Union{Connective,Truth}\n\nUnion type for logical constants of any ariety (zero for Truth values, non-zero for Connectives).\n\nSee also Connective, Truth.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Operator-Tuple{Any}","page":"Home","title":"SoleLogics.Operator","text":"(op::Operator)(o::Any)\n\nAn Operator can be used to compose syntax tokens (e.g., atoms), syntax trees and/or formulas.\n\nExamples\n\n    ¬(Atom(1)) ∨ Atom(1) ∧ ⊤\n    ∧(⊤,⊤)\n    ⊤()\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.Point2DRelations","page":"Home","title":"SoleLogics.Point2DRelations","text":"Vector of 8 cardinal relations from Compass logic: North, South, North-West, etc.\n\nSee also PointRelations.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.PointRelations","page":"Home","title":"SoleLogics.PointRelations","text":"Vector of 6 point relations: min, max, successor, predecessor, >, <.\n\nSee also Point2DRelations.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.RCC5Relations","page":"Home","title":"SoleLogics.RCC5Relations","text":"const RCC5Relations = [Topo_DR, Topo_PO, Topo_PP, Topo_PPi]\n\nVector of the 4 relations from RCC5.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.RCC8Relations","page":"Home","title":"SoleLogics.RCC8Relations","text":"const RCC8Relations = [Topo_DC, Topo_EC, Topo_PO, Topo_TPP, Topo_TPPi, Topo_NTPP, Topo_NTPPi]\n\nVector of the 7 relations from RCC8.\n\nSee also RCC5Relations,  GeometricalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.SyntaxToken","page":"Home","title":"SoleLogics.SyntaxToken","text":"const SyntaxToken = Union{Connective,SyntaxLeaf}\n\nUnion type for values wrapped in SyntaxTree nodes.\n\nSee also SyntaxTree, SyntaxLeaf, Connective.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.TOP","page":"Home","title":"SoleLogics.TOP","text":"const TOP = BooleanTruth(true)\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.globalrel","page":"Home","title":"SoleLogics.globalrel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also identityrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.identityrel","page":"Home","title":"SoleLogics.identityrel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(identityrel)\nIdentityRel()\n\nSee also globalrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.tocenterrel","page":"Home","title":"SoleLogics.tocenterrel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also identityrel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.⊤","page":"Home","title":"SoleLogics.⊤","text":"const TOP = BooleanTruth(true)\nconst ⊤ = TOP\n\nCanonical truth operator representing the value true. It can be typed by \\top<tab>.\n\nSee also BOT, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.⊥","page":"Home","title":"SoleLogics.⊥","text":"const BOT = BooleanTruth(false)\nconst ⊥ = BOT\n\nCanonical truth operator representing the value false. It can be typed by \\bot<tab>.\n\nSee also TOP, Truth.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.□","page":"Home","title":"SoleLogics.□","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box connective, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.◊","page":"Home","title":"SoleLogics.◊","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::typeof(◊)) = true\narity(::typeof(◊)) = 1\n\nLogical diamond connective, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.AbstractAlgebra","page":"Home","title":"SoleLogics.AbstractAlgebra","text":"abstract type AbstractAlgebra{T<:Truth} end\n\nAbstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a lattice structure where two elements(or nodes) ⊤ and ⊥ are referred to as TOP (or maximum) and bot (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.\n\nImplementation\n\nWhen implementing a new algebra type, the methods domain, TOP, and bot should be implemented.\n\nSee also bot, BooleanAlgebra, Operator, TOP, collatetruth, domain, iscrisp, truthtype.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractAlphabet","page":"Home","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, Atom, ExplicitAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractAlphabet-Union{Tuple{Any}, Tuple{V}} where V","page":"Home","title":"SoleLogics.AbstractAlphabet","text":"An alphabet of valuetype V can be used for instantiating atoms of valuetype V.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.AbstractAssignment","page":"Home","title":"SoleLogics.AbstractAssignment","text":"abstract type AbstractAssignment <: AbstractInterpretation end\n\nAbstract type for assigments, that is, interpretations of propositional logic, encoding mappings from Atoms to Truth values.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractDimensionalFrame","page":"Home","title":"SoleLogics.AbstractDimensionalFrame","text":"abstract type AbstractDimensionalFrame{\n    N,\n    W<:AbstractWorld,\n} <: AbstractMultiModalFrame{W} end\n\nAbstract type for dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding dimensional frame is a graph where each vertex is an N-hyperrectangle (e.g., an Interval/Interval2D) in the space (1:X, 1:Y, 1:Z, ...).\n\nSee also Interval, Interval2D, IntervalRelation, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractFrame","page":"Home","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractGrammar","page":"Home","title":"SoleLogics.AbstractGrammar","text":"abstract type AbstractGrammar{V<:AbstractAlphabet,O<:Operator} end\n\nAbstract type for representing a context-free grammar based on a single alphabet of type V, and a set of operators that consists of all the (singleton) child types of O. V context-free grammar is a simple structure for defining formulas inductively.\n\nSee also alphabet, AbstractAlphabet, Operator.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractInterpretation","page":"Home","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractInterpretationSet","page":"Home","title":"SoleLogics.AbstractInterpretationSet","text":"abstract type AbstractInterpretationSet <: AbstractDataset end\n\nAbstract type for ordered sets of interpretations. A set of interpretations, also referred to as a dataset in this context, is a collection of instances, each of which is an interpretation, and is identified by an index iinstance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Modelchecking).\n\nSee alsotruthtype, InterpretationVector.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractKripkeStructure","page":"Home","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractLogic","page":"Home","title":"SoleLogics.AbstractLogic","text":"abstract type AbstractLogic{G<:AbstractGrammar,A<:AbstractAlgebra} end\n\nAbstract type of a logic, which comprehends a context-free grammar (syntax) and an algebra (semantics).\n\nImplementation\n\nWhen implementing a new logic type, the methods grammar and algebra should be implemented.\n\nSee also AbstractAlgebra, AbstractGrammar.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractMultiModalFrame","page":"Home","title":"SoleLogics.AbstractMultiModalFrame","text":"abstract type AbstractMultiModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.\n\nImplementation\n\nWhen implementing a new multi-modal frame type, the logical semantics for the frame should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractUniModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractRelation","page":"Home","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, identityrel, globalrel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractRelationalConnective","page":"Home","title":"SoleLogics.AbstractRelationalConnective","text":"abstract type AbstractRelationalConnective{R<:AbstractRelation} <: Connective end\n\nAbstract type for relational logical connectives. A relational connective allows for semantic quantification across relational structures (e.g., Kripke structures). It has arity equal to the arity of its underlying relation minus one.\n\nSee, for example temporal modal logic.\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractSyntaxStructure","page":"Home","title":"SoleLogics.AbstractSyntaxStructure","text":"abstract type AbstractSyntaxStructure <: Formula end\n\nAbstract type for the purely-syntactic component of a logical formula (e.g., no fancy memoization structure associated). The typical representation is the SyntaxTree, however, different implementations can cover specific syntactic forms (e.g., conjunctive or disjunctive normal forms).\n\nSee also Formula, AbstractLogic, SyntaxTree, tree.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractUniModalFrame","page":"Home","title":"SoleLogics.AbstractUniModalFrame","text":"abstract type AbstractUniModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a modal logic based on a single (implicit) accessibility relation.\n\nSee also AbstractMultiModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractWorld","page":"Home","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractWorlds","page":"Home","title":"SoleLogics.AbstractWorlds","text":"const AbstractWorlds{W} = AbstractVector{W} where {W<:AbstractWorld}\nconst Worlds{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases for dealing with worlds sets/arrays.\n\nSee also accessibles, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AlphabetOfAny","page":"Home","title":"SoleLogics.AlphabetOfAny","text":"struct AlphabetOfAny{V} <: AbstractAlphabet{V} end\n\nAn implicit, infinite alphabet that includes all atoms with values of a subtype of V.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AnchoredFormula","page":"Home","title":"SoleLogics.AnchoredFormula","text":"struct AnchoredFormula{L<:AbstractLogic} <: Formula\n    _logic::Base.RefValue{L}\n    synstruct::AbstractSyntaxStructure\nend\n\nA formula anchored to a logic of type L, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.\n\nUpon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:\n\ncheck_atoms::Bool = false: whether to perform or not a check that the atoms   belong to the alphabet of the logic;\ncheck_tree::Bool = false: whether to perform or not a check that the formula's   syntactic structure honors the grammar   (includes the check performed with check_atoms = true);\n\nCool feature: a AnchoredFormula can be used for instating other formulas of the same logic. See the examples.\n\nExamples\n\njulia> φ = parsebaseformula(\"◊(p→q)\");\n\njulia> f2 = φ(parseformula(\"p\"));\n\njulia> syntaxstring(φ)\n\"◊(→(p, q))\"\n\njulia> syntaxstring(f2)\n\"p\"\n\njulia> @assert logic(φ) == logic(f2)\n\njulia> @assert ◊ in operators(logic(f2))\n\njulia> @assert ◊ isa operatorstype(logic(f2))\n\n\nSee also AbstractLogic, logic, SyntaxToken, SyntaxBranch, tree.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AtWorldRelation","page":"Home","title":"SoleLogics.AtWorldRelation","text":"A binary relation via which a world is accessed by every other world within the frame. That is, the binary relation that leads to a world.\n\nSee also identityrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Atom","page":"Home","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, atoms, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.BaseLogic","page":"Home","title":"SoleLogics.BaseLogic","text":"struct BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra} <: AbstractLogic{G,A}\n    grammar::G\n    algebra::A\nend\n\nA basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.\n\nSee also grammar, algebra, AbstractGrammar, AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.BooleanAlgebra","page":"Home","title":"SoleLogics.BooleanAlgebra","text":"struct BooleanAlgebra <: AbstractAlgebra{Bool} end\n\nA Boolean algebra, defined on the values TOP (representing truth) and BOT (for bottom, representing falsehood). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of true and false, respectively.\n\nSee also Truth.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.BooleanTruth","page":"Home","title":"SoleLogics.BooleanTruth","text":"struct BooleanTruth <: Truth\n    flag::Bool\nend\n\nStructure for representing the Boolean truth values ⊤ and ⊥. It wraps a flag which takes value true for ⊤ (TOP), and false for ⊥ (BOT)\n\nSee also BooleanAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.BoxRelationalConnective","page":"Home","title":"SoleLogics.BoxRelationalConnective","text":"struct DiamondRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\nstruct BoxRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\n\nSingleton types for relational connectives, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth connectives can be easily instantiated with relation instances, such as DiamondRelationalConnective(rel), which is a shortcut for DiamondRelationalConnective{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalConnective(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalConnective(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalConnective(IA_A) == SoleLogics.dual(BoxRelationalConnective(IA_A))\n\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.CNF","page":"Home","title":"SoleLogics.CNF","text":"CNF{SS<:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostDisjunctiveForm{SS}}\n\nConjunctive Normal Form of an AbstractSyntaxStructure.\n\nSee also AbstractSyntaxStructure, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, CONJUNCTION, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.CompleteFlatGrammar","page":"Home","title":"SoleLogics.CompleteFlatGrammar","text":"struct CompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator} <: AbstractGrammar{V,O}\n    alphabet::V\n    operators::Vector{<:O}\nend\n\nV grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type V, and all operators in operators. With n operators, this grammar has exactly n+1 production rules. For example, with operators = [∧,∨], the grammar (in Backus-Naur form) is:\n\nφ ::= p | φ ∧ φ | φ ∨ φ\n\nwith p ∈ alphabet. Note: it is flat in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.\n\nSee also AbstractGrammar, Operator, alphabet, formulas, connectives, operators, leaves.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Connective","page":"Home","title":"SoleLogics.Connective","text":"abstract type Connective <: Syntactical end\n\nAbstract type for logical connectives, that are used to express non-atomic statements; for example, CONJUNCTION, DISJUNCTION, NEGATION and IMPLICATION (stylized as ∧, ∨, ¬ and →).\n\nImplementation\n\nWhen implementing a new type C for a connective, please define its arity. For example, with a binary operator (e.g., ∨ or ∧):\n\narity(::C) = 2\n\nWhen implementing a new type C for a commutative connective with arity higher than 1, please provide a method iscommutative(::C). This can speed up model checking operations.\n\nWhen implementing a custom binary connective, one can override the default precedence and associativity (see here. If the custom connective is a NamedConnective and renders as something considered as a math symbol (for example, ⊙, see https://stackoverflow.com/a/60321302/5646732), by the Julia parser, Base.operator_precedence and Base.operator_associativity are used to define these behaviors, and you might want to avoid providing these methods at all.\n\nThe semantics of a propositional connective can be specified via collatetruth (see example below); in principle, the definition can rely on the partial order between truth values (specified via precedes).\n\nHere is an example of a custom implementation of the xor (⊻) Boolean operator.\n\nimport SoleLogics: arity, iscommutative, collatetruth\nconst ⊻ = SoleLogics.NamedConnective{:⊻}()\nSoleLogics.arity(::typeof(⊻)) = 2\nSoleLogics.iscommutative(::typeof(⊻)) = true\nSoleLogics.collatetruth(::typeof(⊻), (t1, t2)::NTuple{N,T where T<:BooleanTruth}) where {N} = (count(istop, (t1, t2)) == 1)\n\nNote that collatetruth must be defined at least for some truth value types T via methods accepting an NTuple{arity,T} as a second argument.\n\nTo make the operator work with incomplete interpretations (e.g., when the Truth value for an atom is not known), simplification rules for NTuple{arity,T where T<:Formula}s should be provided via methods for simplify. For example, these rules suffice for simplifying xors between TOP/BOT`s, and other formulas:\n\nimport SoleLogics: simplify\nsimplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,BooleanTruth}) = istop(t1) == istop(t2) ? BOT : TOP\nsimplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,Formula}) = istop(t1) ? ¬t2 : t2\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Formula,BooleanTruth}) = istop(t2) ? ¬t1 : t1\n\nBeware of dispatch ambiguities!\n\nSee also arity, SyntaxBranch, associativity, precedence, check, iscommutative, NamedConnective, Syntactical.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.DNF","page":"Home","title":"SoleLogics.DNF","text":"DNF{SS<:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostConjunctiveForm{SS}}\n\nDisjunctive Normal Form of an AbstractSyntaxStructure.\n\nSee also AbstractSyntaxStructure, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, CONJUNCTION, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.DefaultedTruthDict","page":"Home","title":"SoleLogics.DefaultedTruthDict","text":"struct DefaultedTruthDict{\n    D<:AbstractDict{A where A<:Atom,T where T<:Truth},\n    T<:Truth\n} <: AbstractAssignment\n    truth::D\n    default_truth::T\nend\n\nA truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns default_truth.\n\nExamples\n\njulia> t1 = DefaultedTruthDict(string.(1:4), false); t1[\"5\"] = false; t1\nDefaultedTruthDict with default truth `⊥` and values:\n┌────────┬────────┬────────┬────────┬────────┐\n│      4 │      1 │      5 │      2 │      3 │\n│ String │ String │ String │ String │ String │\n├────────┼────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊥ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┴────────┘\n\njulia> check(parseformula(\"1 ∨ 2\"), t1)\ntrue\n\njulia> check(parseformula(\"1 ∧ 5\"), t1)\nfalse\n\n\nSee also TruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.DiamondRelationalConnective","page":"Home","title":"SoleLogics.DiamondRelationalConnective","text":"struct DiamondRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\nstruct BoxRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\n\nSingleton types for relational connectives, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth connectives can be easily instantiated with relation instances, such as DiamondRelationalConnective(rel), which is a shortcut for DiamondRelationalConnective{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalConnective(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalConnective(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalConnective(IA_A) == SoleLogics.dual(BoxRelationalConnective(IA_A))\n\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.ExplicitAlphabet","page":"Home","title":"SoleLogics.ExplicitAlphabet","text":"struct ExplicitAlphabet{V} <: AbstractAlphabet{V}\n    atoms::Vector{Atom{V}}\nend\n\nAn alphabet wrapping atoms in a (finite) Vector.\n\nSee also AbstractAlphabet, atoms.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.ExplicitCrispUniModalFrame","page":"Home","title":"SoleLogics.ExplicitCrispUniModalFrame","text":"TODO\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.FilteredRelation","page":"Home","title":"SoleLogics.FilteredRelation","text":"struct FilteredRelation{R<:AbstractRelation,F<:WorldFilter} <: AbstractRelation\n    r::R\n    wf::F\nend\n\nA (binary) accessibility relation r, filtered by a world filter wf.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Formula","page":"Home","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), AbstractSyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nSee also tree, AbstractSyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.FullDimensionalFrame","page":"Home","title":"SoleLogics.FullDimensionalFrame","text":"struct FullDimensionalFrame{N,W<:AbstractWorld} <: AbstractDimensionalFrame{N,W}\n    channelsize::NTuple{N,Int}\nend\n\nAbstract type for full dimensional frames. Given a N-dimensional array of size (X, Y, Z, ...) the corresponding full dimensional frame is a graph where there is exactly one vertex for each M-hyperrectangle in the space (1:X, 1:Y, 1:Z, ...), with M ≤ N.\n\nHere, the M-hyperrectangle can be either a Point, or a N-tuple of intervals (e.g., Interval or Interval2D), where each interval is a pair of natural numbers (x,y) where: i) x > 0; ii) y > 0; iii) x < y.\n\nThe current implementation can handle N ∈ {0,1,2}.\n\nExamples\n\njulia> SoleLogics.allworlds(SoleLogics.FullDimensionalFrame((),))\n1-element Vector{OneWorld}:\n −\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,),))\n55\n\njulia> nworlds(SoleLogics.FullDimensionalFrame((10,10),))\n3025\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also OneWorld, Interval, Interval2D, IntervalRelation, RectangleRelation, accessibles, AbstractDimensionalFrame, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.FunctionalWorldFilter","page":"Home","title":"SoleLogics.FunctionalWorldFilter","text":"struct FunctionalWorldFilter{W <: AbstractWorld, F <: Function} <: WorldFilter{W}\n\tfilter::FunctionWrapper{Bool, Tuple{W}}\nend\n\nFunctionalWorldFilter{W, F}(filter::FunctionWrapper{Bool, Tuple{W}}) where {W <: AbstractWorld, F <: Function}\nFunctionalWorldFilter(filter::FunctionWrapper{Bool, Tuple{W}}, functiontype::Type{F}) where {W <: AbstractWorld, F <: Function}\nFunctionalWorldFilter{W, F}(filter::F) where {W <: AbstractWorld, F <: Function}\nFunctionalWorldFilter{W}(filter::F) where {W <: AbstractWorld, F <: Function}\nFunctionalWorldFilter(filter::F, worldtype::Type{W}) where {W <: AbstractWorld, F <: Function}\n\nPlease provide a function as filter so that it takes as input an object subtype of AbstractWorld and it gives as output a Bool.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.GeometricalRelation","page":"Home","title":"SoleLogics.GeometricalRelation","text":"abstract type GeometricalWorld <: AbstractRelation end\n\nAbstract type for relations with a geometrical interpretation.\n\nSee also istopological, IntervalRelation, RectangleRelation, RCCRelation, AbstractRelation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.GeometricalWorld","page":"Home","title":"SoleLogics.GeometricalWorld","text":"abstract type GeometricalWorld <: AbstractWorld end\n\nAbstract type for worlds with a geometrical interpretation.\n\nSee also Point, Interval, Interval2D, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.GlobalRel","page":"Home","title":"SoleLogics.GlobalRel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also identityrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.IdentityRel","page":"Home","title":"SoleLogics.IdentityRel","text":"struct IdentityRel <: AbstractRelation end;\nconst identityrel   = IdentityRel();\n\nSingleton type for the identity relation. This is a binary relation via which a world accesses itself. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.identityrel)\n\"=\"\n\njulia> SoleLogics.converse(identityrel)\nIdentityRel()\n\nSee also globalrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.InterpretationVector","page":"Home","title":"SoleLogics.InterpretationVector","text":"struct InterpretationVector{M<:AbstractInterpretation} <: AbstractInterpretationSet\n    instances::Vector{M}\nend\n\nA dataset of interpretations instantiated as a vector.\n\nAbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval","page":"Home","title":"SoleLogics.Interval","text":"struct Interval{T} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval2D","page":"Home","title":"SoleLogics.Interval2D","text":"struct Interval2D{T} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.IntervalRelation","page":"Home","title":"SoleLogics.IntervalRelation","text":"abstract type IntervalRelation <: GeometricalRelation end\n\nAbstract type for interval binary relations. Originally defined by Allen in 1983, interval algebra comprehends 12 directional relations between intervals, plus the identity (i.e., identityrel).\n\nThe 12 relations are the 6 relations after, later, begins, ends, during, overlaps, and their inverses.\n\nIf we consider a reference interval (x−y), we can graphically represent the 6 base relations by providing an example of a world (z−t) that is accessible via each of them:\n\nRelation Full name Property Graphical Representation w.r.t (x−y)\n   _____x___________________y________________\n   _____∣−−−−−−−−−−−−−−−−−−−∣________________\n   _____.___________________.________________\n   _____.___________________z________t_______\nA After (or meets) y = z _____.___________________∣−−−−−−−−∣_______\n   _____.___________________.________________\n   _____.___________________.___z_________t__\nL Later y < z _____.___________________.___∣−−−−−−−−−∣__\n   _____.___________________.________________\n   _____z_____t_____________.________________\nB Begins (or starts) x = z, t < y _____∣−−−−−∣_____________.________________\n   _____.___________________.________________\n   _____._____________z_____t________________\nE Ends (or finishes) y = t, x < z _____._____________∣−−−−−∣________________\n   _____.___________________.________________\n   _____.___z________t______.________________\nD During x < z, t < y _____.___∣−−−−−−−−∣______.________________\n   _____.___________________.________________\n   _____.___________z_______.____t___________\nO Overlaps x < z < y < t _____.___________∣−−−−−−−−−−−−∣___________\n\nCoarser relations can be defined by union of these 12 relations.\n\nExamples\n\njulia> IARelations\n12-element Vector{IntervalRelation}:\n _IA_A()\n _IA_L()\n _IA_B()\n _IA_E()\n _IA_D()\n _IA_O()\n _IA_Ai()\n _IA_Li()\n _IA_Bi()\n _IA_Ei()\n _IA_Di()\n _IA_Oi()\n\njulia> @assert SoleLogics._IA_L() == IA_L\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(2,5), IA_L))\n15-element Vector{Interval{Int64}}:\n (6−7)\n (6−8)\n (7−8)\n (6−9)\n (7−9)\n (8−9)\n (6−10)\n (7−10)\n (8−10)\n (9−10)\n (6−11)\n (7−11)\n (8−11)\n (9−11)\n (10−11)\n\njulia> syntaxstring.(IARelations)\n12-element Vector{String}:\n \"A\"\n \"L\"\n \"B\"\n \"E\"\n \"D\"\n \"O\"\n \"A̅\"\n \"L̅\"\n \"B̅\"\n \"E̅\"\n \"D̅\"\n \"O̅\"\n\njulia> syntaxstring.(IA7Relations)\n6-element Vector{String}:\n \"AO\"\n \"L\"\n \"DBE\"\n \"A̅O̅\"\n \"L̅\"\n \"D̅B̅E̅\"\n\njulia> syntaxstring.(SoleLogics.IA3Relations)\n3-element Vector{String}:\n \"I\"\n \"L\"\n \"L̅\"\n\n\nSee also IARelations, IA7Relations, IA3Relations, Interval, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.KripkeStructure","page":"Home","title":"SoleLogics.KripkeStructure","text":"struct KripkeStructure{\n    FR<:AbstractFrame,\n    MAS<:AbstractDict\n} <: AbstractKripkeStructure\n    frame::FR\n    assignment::AS\nend\n\nType for representing Kripke structures. explicitly; it wraps a frame, and an abstract dictionary that assigns an interpretation to each world.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.LeftmostConjunctiveForm","page":"Home","title":"SoleLogics.LeftmostConjunctiveForm","text":"LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\n\nSpecific instantiation of a LeftmostLinearForm, where Connectives are all CONJUNCTIONs.\n\nSee also AbstractSyntaxStructure, Connective, LeftmostLinearForm, CONJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.LeftmostDisjunctiveForm","page":"Home","title":"SoleLogics.LeftmostDisjunctiveForm","text":"LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nSpecific instantiation of a LeftmostLinearForm, where Connectives are all DISJUNCTIONs.\n\nSee also AbstractSyntaxStructure, Connective, LeftmostLinearForm, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.LeftmostLinearForm","page":"Home","title":"SoleLogics.LeftmostLinearForm","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}}\n    \"(p) → (q) → (r)\"\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    \"(¬p) ∧ (q) ∧ (¬r)\"\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    \"(¬p) ∨ (q) ∨ (¬r)\"\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa DNF\ntrue\n\njulia> conj = LeftmostConjunctiveForm(@atoms p q)\nLeftmostConjunctiveForm with 2 Atom{String} children:\n        p\n        q\n\njulia> tree(conj)\nSyntaxBranch: p ∧ q\n\njulia> nconj = NEGATION(conj)\nLeftmostLinearForm with connective ¬ and 1 LeftmostConjunctiveForm{Atom{String}} children:\n        (p) ∧ (q)\n\njulia> tree(nconj)\nSyntaxBranch: ¬(p ∧ q)\n\njulia> tree(nconj ∧ nconj)\nSyntaxBranch: ¬(p ∧ q) ∧ ¬(p ∧ q)\n\nSee also AbstractSyntaxStructure, SyntaxTree, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, Literal.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Literal","page":"Home","title":"SoleLogics.Literal","text":"struct Literal{T<:SyntaxLeaf} <: AbstractSyntaxStructure\n    ispos::Bool\n    prop::T\nend\n\nAn atom, or its negation.\n\nSee also CNF, DNF, AbstractSyntaxStructure.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.LogicalInstance","page":"Home","title":"SoleLogics.LogicalInstance","text":"struct LogicalInstance{S<:AbstractInterpretationSet}\n    s::S\n    i_instance::Int64\nend\n\nObject representing the i-th interpretation of an interpretation set.\n\nIn general, one may not be able to extract a single logical instance from a set; thus, this representation, holding the interpretation set + instance id (i_instance), can come handy in defining check and interpret methods for newly defined interpretation set structures.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.NamedConnective","page":"Home","title":"SoleLogics.NamedConnective","text":"struct NamedConnective{Symbol} <: Connective end\n\nA singleton type for representing connectives defined by a name or a symbol.\n\nExamples\n\nThe AND connective (i.e., the logical conjunction) is defined as the subtype:\n\nconst CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.NamedRelation","page":"Home","title":"SoleLogics.NamedRelation","text":"struct NamedRelation{T} <: AbstractRelation\n    name::T\nend\n\nType for relations that are solely defined by their name.\n\nSee also AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.OneWorld","page":"Home","title":"SoleLogics.OneWorld","text":"struct OneWorld <: AbstractWorld end\n\nA singleton world to be used in modal frames with a single, unique world. This usage effectively simulates a propositional context. Note that it is compatible with 0-dimensional datasets.\n\nSee also Interval, Interval2D, goeswithdim, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Point","page":"Home","title":"SoleLogics.Point","text":"struct Point{N,T} <: GeometricalWorld\n    xyz :: NTuple{N,T}\nend\n\nA point in an N-dimensional space, with integer coordinates.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),3)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Point(1,2,3),2)\nfalse\n\n\nSee also goeswithdim, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Point2DRelation","page":"Home","title":"SoleLogics.Point2DRelation","text":"2D Point relations (see Compass logic)\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.PointRelation","page":"Home","title":"SoleLogics.PointRelation","text":"1D Point relations\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.RCCRelation","page":"Home","title":"SoleLogics.RCCRelation","text":"abstract type RCCRelation <: GeometricalRelation end\n\nTopological binary relations from Region Connection Calculus. Region Connection Calculus (RCC) is most famous for RCC8, a set of 8 topological relations, which comprehends the identity relation (i.e., `identityrel'), and the following 7 relations:\n\nExternally connected;\nPartially overlapping;\nTangential proper part;\nTangential proper part inverse;\nNon-tangential proper part;\nNon-tangential proper part inverse.\n\nIf we consider a reference interval (x−y), we can graphically represent the 7  relations by providing an example of a world (z−t) that is accessible via each of them:\n\nRelation Full name Graphical Representation w.r.t (x−y)\n  ___x___________________y__________________\n  ___∣−−−−−−−−−−−−−−−−−−−∣__________________\n  ___.___________________.__________________\n  ___.___________________.__z________t______\nDC Disconnected ___.___________________._∣−−−−−−−−∣_______\n  ___.___________________.__________________\n  ___.___________________z_________t________\nEC Externally connected ___.___________________∣−−−−−−−−−∣________\n  ___.___________________.__________________\n  ___.________________z_____t_______________\nPO Partially overlapping ___.________________∣−−−−−∣_______________\n  ___.___________________.__________________\n  ___._____________z_____t__________________\nTPP Tangential proper part ___._____________∣−−−−−∣__________________\n  ___.___________________.__________________\n  ___z___________________._____t____________\nTPPi Tangential proper part inverse ___∣−−−−−−−−−−−−−−−−−−−−−−−−−∣____________\n  ___.___________________.__________________\n  ___.___________z_______.__________________\nNTPP Non-tangential proper part ___.___________∣−−−−−∣_.__________________\n  ___.___________________.__________________\n  _z_.___________________._t________________\nNTPPi Non-tangential proper part inverse _∣−−−−−−−−−−−−−−−−−−−−−−−∣________________\n\nMethods for RCC8 relations and Interval2D's can be obtained by combining their 1D versions, according to the following composition rules:\n\n DC EC PO TPP TPP NTPP NTPP Id\nDC DC DC DC DC DC DC DC DC\nEC DC EC EC EC EC EC EC EC\nPO DC EC PO PO PO PO PO PO\nTPP DC EC PO TPP PO TPP PO TPP\nTPPi DC EC PO PO TPP PO TPP TPP\nNTPP DC EC PO TPP PO NTPP PO TPP\nNTPPi DC EC PO PO TPP PO NTPP TPP\nId DC EC PO TPP TPP TPP TPP Id\n\nExamples\n\njulia> RCC8Relations\n7-element Vector{RCCRelation}:\n _Topo_DC()\n _Topo_EC()\n _Topo_PO()\n _Topo_TPP()\n _Topo_TPPi()\n _Topo_NTPP()\n _Topo_NTPPi()\n\njulia> @assert SoleLogics._Topo_DC() == Topo_DC\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> collect(accessibles(fr, Interval(4,8), Topo_DC))\n6-element Vector{Interval{Int64}}:\n (9−10)\n (9−11)\n (10−11)\n (1−2)\n (1−3)\n (2−3)\n\njulia> syntaxstring.(RCC8Relations)\n7-element Vector{String}:\n \"DC\"\n \"EC\"\n \"PO\"\n \"TPP\"\n \"T̅P̅P̅\"\n \"NTPP\"\n \"N̅T̅P̅P̅\"\n\njulia> RCC5Relations\n4-element Vector{RCCRelation}:\n _Topo_DR()\n _Topo_PO()\n _Topo_PP()\n _Topo_PPi()\n\nSee also  RCC8Relations, RCC5Relations, Interval, IntervalRelation, GeometricalRelation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.RectangleRelation","page":"Home","title":"SoleLogics.RectangleRelation","text":"const IABase = Union{IntervalRelation,IdentityRel,GlobalRel}\nstruct RectangleRelation{R1<:IABase,R2<:IABase} <: GeometricalRelation\n    x :: R1\n    y :: R2\nend\n\nRelation from 2D interval algebra, obtained from the combination of orthogonal interval relations,  and are thus also referred to as rectangle algebra.\n\nExamples\n\njulia> syntaxstring.(IA2DRelations[1:20:end])\n9-element Vector{String}:\n \"=,A\"\n \"A,L̅\"\n \"B,L\"\n \"E,B̅\"\n \"O,B\"\n \"A̅,E̅\"\n \"B̅,E\"\n \"E̅,D̅\"\n \"O̅,D\"\n\njulia> length(IA2DRelations)\n168\n\nSee also Interval, Interval2D, IntervalRelation, [[GeometricalRelation`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Syntactical","page":"Home","title":"SoleLogics.Syntactical","text":"abstract type Syntactical end\n\nMaster abstract type for all syntactical objects (e.g., formulas, connectives).\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.SyntaxBranch","page":"Home","title":"SoleLogics.SyntaxBranch","text":"struct SyntaxBranch <: SyntaxTree\n    token::Connective\n    children::NTuple{N,SyntaxTree} where {N}\nend\n\nAn internal node of a syntax tree encoding a logical formula. Such a node holds a syntax token (a Connective, and has as many children as the arity of the token.\n\nThis implementation is arity-compliant, in that, upon construction, the arity of the token is checked against the number of children provided.\n\nExamples\n\njulia> p,q = Atom.([p, q])\n2-element Vector{Atom{String}}:\n Atom{String}: p\n Atom{String}: q\n\njulia> branch = SyntaxBranch(CONJUNCTION, p, q)\nSyntaxBranch: p ∧ q\n\njulia> token(branch)\n∧\n\njulia> syntaxstring.(children(branch))\n(p, q)\n\njulia> ntokens(a) == nconnectives(a) + nleaves(a)\ntrue\n\njulia> arity(a)\n2\n\njulia> height(a)\n1\n\nSee also token, children, arity, Connective, height, atoms, natoms, operators, noperators, tokens, ntokens,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.SyntaxLeaf","page":"Home","title":"SoleLogics.SyntaxLeaf","text":"abstract type SyntaxLeaf <: AbstractSyntaxStructure end\n\nAn atomic logical element, like a Truth value or an Atom. SyntaxLeafs have arity equal to zero, meaning that they are not allowed to have children in tree-like syntactic structures.\n\nSee also AbstractSyntaxStructure,  arity, SyntaxBranch.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.SyntaxTree","page":"Home","title":"SoleLogics.SyntaxTree","text":"abstract type SyntaxTree <: AbstractSyntaxStructure end\n\nAbstract type for syntax trees; that is, syntax leaves (see SyntaxLeaf, such as Truth values and Atoms), and their composition via Connectives (i.e., SyntaxBranch).\n\nnote: Note\nNote that SyntaxTrees are ranked trees, and (should) adhere to the AbstractTrees interface.\n\nSee also SyntaxLeaf, SyntaxBranch, AbstractSyntaxStructure, Formula.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.ToCenteredRel","page":"Home","title":"SoleLogics.ToCenteredRel","text":"struct ToCenteredRel <: AbstractRelation end;\nconst tocenterrel = ToCenteredRel();\n\nSingleton type for a relation that leads to the world at the center of a frame. The relation is transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.tocenterrel)\n\"◉\"\n\nSee also identityrel, centralworld, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Truth","page":"Home","title":"SoleLogics.Truth","text":"abstract type Truth <: SyntaxLeaf end\n\nAbstract type for syntax leaves representing values of a lattice algebra. In Boolean logic, the two BooleanTruth values TOP (⊤) and BOT (⊥) are used.\n\nSee also BooleanTruth.\n\nImplementation\n\nA three-valued algebra, that is, an algebra with three truth values (top, bottom and unknown), can be based on the following Truth value definitions:\n\nimport SoleLogics: precedes\n\nabstract type ThreeVTruth <: Truth end\n\nstruct ThreeTop <: ThreeVTruth end\nconst ⫪ = ThreeTop() # Note that ⊤ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeTop; kwargs...) = \"⫪\"\n\nstruct ThreeBot <: ThreeVTruth end\nconst ⫫ = ThreeBot() # Note that ⊥ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeBot; kwargs...) = \"⫫\"\n\nstruct ThreeUnknown <: ThreeVTruth end\nconst υ = ThreeUnknown()\nsyntaxstring(::ThreeUnknown; kwargs...) = \"υ\"\n\nistop(t::ThreeTop) = true\nisbot(t::ThreeBot) = true\n\nprecedes(::ThreeBot, ::ThreeTop) = true\nprecedes(::ThreeBot, ::ThreeUnknown) = true\nprecedes(::ThreeUnknown, ::ThreeTop) = true\nprecedes(::ThreeTop, ::ThreeBot) = false\nprecedes(::ThreeUnknown, ::ThreeBot) = false\nprecedes(::ThreeTop, ::ThreeUnknown) = false\n\nNote that precedes is used to define the (partial) order between Truth values.\n\nSee also Connective, BooleanTruth.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.TruthDict","page":"Home","title":"SoleLogics.TruthDict","text":"struct TruthDict{D<:AbstractDict{A where A<:Atom,T where T<:Truth}} <: AbstractAssignment\n    truth::D\nend\n\nA logical interpretation instantiated as a dictionary, explicitly assigning truth values to a finite set of atoms.\n\nExamples\n\njulia> TruthDict(1:4)\nTruthDict with values:\n┌────────┬────────┬────────┬────────┐\n│      4 │      2 │      3 │      1 │\n│  Int64 │  Int64 │  Int64 │  Int64 │\n├────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┘\n\n\njulia> t1 = TruthDict(1:4, false); t1[5] = true; t1\nTruthDict with values:\n┌───────┬───────┬───────┬───────┬───────┐\n│     5 │     4 │     2 │     3 │     1 │\n│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │\n├───────┼───────┼───────┼───────┼───────┤\n│     ⊤ │     ⊥ │     ⊥ │     ⊥ │     ⊥ │\n└───────┴───────┴───────┴───────┴───────┘\n\njulia> t2 = TruthDict([\"a\" => true, \"b\" => false, \"c\" => true])\nTruthDict with values:\n┌────────┬────────┬────────┐\n│      c │      b │      a │\n│ String │ String │ String │\n├────────┼────────┼────────┤\n│      ⊤ │      ⊥ │      ⊤ │\n└────────┴────────┴────────┘\n\njulia> check(parseformula(\"a ∨ b\"), t2)\ntrue\n\n\nnote: Note\nIf prompted for the value of an unknown atom, this throws an error. If boolean, integer, or float values are specified, they are converted to Truth values. If the structure is initialized as empty, BooleanTruth values are assumed.\n\nSee also DefaultedTruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.TruthTable","page":"Home","title":"SoleLogics.TruthTable","text":"struct TruthTable{A,T<:Truth}\n\nDictionary which associates an AbstractAssignments to the truth value of the assignment itself on a AbstractSyntaxStructure.\n\nSee also AbstractAssignment, AbstractSyntaxStructure, Truth.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.World","page":"Home","title":"SoleLogics.World","text":"struct World{T} <: AbstractWorld\n    name::T\nend\n\nA world that is solely identified by its name. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.\n\nSee also OneWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Worlds","page":"Home","title":"SoleLogics.Worlds","text":"const AbstractWorlds{W} = AbstractVector{W} where {W<:AbstractWorld}\nconst Worlds{W} = Vector{W} where {W<:AbstractWorld}\n\nUseful aliases for dealing with worlds sets/arrays.\n\nSee also accessibles, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.WrapperMultiModalFrame","page":"Home","title":"SoleLogics.WrapperMultiModalFrame","text":"struct WrapperMultiModalFrame{\n    W<:AbstractWorld,\n    D<:AbstractDict{<:AbstractRelation,<:AbstractUniModalFrame{W}}\n} <: AbstractMultiModalFrame{W}\n    frames::D\nend\n\nA multi-modal frame that is the superposition of many uni-modal frames. It uses a single AbstractUniModalFrame for each of relations.\n\nSee also AbstractRelation, AbstractUniModalFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._GreaterRel","page":"Home","title":"SoleLogics._GreaterRel","text":"Relation leading to the greater Points in the linear order.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._LesserRel","page":"Home","title":"SoleLogics._LesserRel","text":"Relation leading to the lesser Points in the linear order.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._MaxRel","page":"Home","title":"SoleLogics._MaxRel","text":"Relation leading to the maximum Point (i.e., the greatest in the linear order).\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._MinRel","page":"Home","title":"SoleLogics._MinRel","text":"Relation leading to the minimum Point (i.e., the least in the linear order).\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._PredecessorRel","page":"Home","title":"SoleLogics._PredecessorRel","text":"Relation leading to the predecessor Point (i.e., the previous in the linear order).\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics._SuccessorRel","page":"Home","title":"SoleLogics._SuccessorRel","text":"Relation leading to the successor Point (i.e., the next in the linear order).\n\n\n\n\n\n","category":"type"},{"location":"#AbstractTrees.children-Tuple{SyntaxTree}","page":"Home","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nReturn the immediate children of a syntax tree.\n\nSee also SyntaxBranch, SyntaxLeaf.\n\n\n\n\n\n","category":"method"},{"location":"#Base.haskey-Tuple{SoleLogics.AbstractAssignment, Atom}","page":"Home","title":"Base.haskey","text":"Base.haskey(i::AbstractAssignment, ::Atom)::Bool\n\nReturn whether an assigment has a truth value for a given atom.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}","page":"Home","title":"Base.in","text":"Base.in(p::Atom, a::AbstractAlphabet)::Bool\n\nReturn whether an atom belongs to an alphabet.\n\nSee also AbstractAlphabet, Atom.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{SyntaxToken, SyntaxTree}","page":"Home","title":"Base.in","text":"Base.in(tok::SyntaxToken, φ::Formula)::Bool\n\nReturn whether a syntax token appears in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}","page":"Home","title":"Base.in","text":"Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isfinite-Tuple{Type{<:SoleLogics.AbstractAlphabet}}","page":"Home","title":"Base.isfinite","text":"Base.isfinite(a::AbstractAlphabet)\n\nReturn true if the alphabet is finite, false otherwise.\n\nSee AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}","page":"Home","title":"Base.iterate","text":"Base.iterate(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet, state)\n\nReturn an iterator to the next element in an alhabet.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}","page":"Home","title":"Base.rand","text":"Base.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    alphabet::AbstractAlphabet,\n    args...;\n    kwargs...\n)::Atom\n\nBase.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG],\n    height::Integer,\n    l::AbstractLogic,\n    args...;\n    kwargs...\n)::Formula\n\nBase.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    height::Integer,\n    g::CompleteFlatGrammar,\n    args...\n)::Formula\n\nBase.rand(\n    height::Integer,\n    connectives::Union{AbstractVector{<:Operator},AbstractVector{<:Connective}},\n    atoms::Union{AbstractVector{<:Atom},AbstractAlphabet},\n    truthvalues::Union{Nothing,AbstractAlgebra,AbstractVector{<:Truth}} = nothing,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    kwargs...\n)::Formula\n\nRandomly generate an Atom from an AbstractAlphabet according to a uniform distribution. If a CompleteFlatGrammar is provided together with an height a Formula could also be generated.\n\nImplementation\n\nIf the alphabet is finite, the function defaults to rand(rng, atoms(alphabet)); otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also AbstractAlphabet, Atom, CompleteFlatGrammar, Formula, randformula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.:≺","page":"Home","title":"SoleLogics.:≺","text":"Alias for precedes.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame, W, AbstractRelation}} where W<:AbstractWorld","page":"Home","title":"SoleLogics.accessibles","text":"accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{<:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W<:AbstractWorld","page":"Home","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}","page":"Home","title":"SoleLogics.algebra","text":"algebra(l::AbstractLogic{G,V})::V where {G,V}\n\nReturn the algebra of a given logic.\n\nSee also AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W<:AbstractWorld","page":"Home","title":"SoleLogics.allworlds","text":"allworlds(fr::AbstractFrame{W})::AbstractVector{<:W} where {W<:AbstractWorld}\n\nReturn all worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}","page":"Home","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{V} where {V})::V\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.alphabet-Tuple{SoleLogics.AbstractInterpretationSet}","page":"Home","title":"SoleLogics.alphabet","text":"alphabet(s::AbstractInterpretationSet)::Alphabet\n\nReturn the propositional alphabet of an interpretation set.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.arity-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.arity","text":"arity(::AbstractRelation)::Integer\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.arity-Tuple{Connective}","page":"Home","title":"SoleLogics.arity","text":"arity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.arity-Tuple{SyntaxTree}","page":"Home","title":"SoleLogics.arity","text":"arity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.associativity-Tuple{Connective}","page":"Home","title":"SoleLogics.associativity","text":"associativity(::Connective)\n\nReturn whether a (binary) connective is right-associative.\n\nWhen using infix notation, and in the absence of parentheses, associativity establishes how binary connectives of the sameprecedenceare interpreted. This affects how formulas are shown (viasyntaxstring) and parsed (viaparseformula`).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); thus, for example, most connectives are left-associative (e.g., ∧ and ∨), while → is right-associative. Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nExamples\n\njulia> associativity(∧)\n:left\n\njulia> associativity(→)\n:right\n\njulia> syntaxstring(parseformula(\"p → q → r\"); remove_redundant_parentheses = false)\n\"p → (q → r)\"\n\njulia> syntaxstring(parseformula(\"p ∧ q ∨ r\"); remove_redundant_parentheses = false)\n\"(p ∧ q) ∨ r\"\n\nSee also Connective, parseformula, precedence, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.atoms-Tuple{Formula}","page":"Home","title":"SoleLogics.atoms","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Home","title":"SoleLogics.atoms","text":"atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nList the atoms of a finite alphabet.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.baseformula-Tuple{Formula}","page":"Home","title":"SoleLogics.baseformula","text":"function baseformula(\n    φ::Formula;\n    infer_logic = true,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing,\n    kwargs...\n)\n\nAttempt at instantiating a AnchoredFormula from a syntax token/formula, by inferring the logic it belongs to. If infer_logic is true, then a canonical logic (e.g., propositional logic with all the BASE_PROPOSITIONAL_CONNECTIVES) is inferred; if it's false, then a logic with exactly the operators appearing in the syntax tree, plus the additional_operators is instantiated.\n\nExamples\n\njulia> t = parseformula(\"◊((p∧q)→r)\");\n\njulia> unique(operators(logic(SoleLogics.baseformula(t))))\n3-element Vector{Union{SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:∧}}}:\n ∧\n ◊\n →\n\njulia> unique(operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_CONNECTIVES))))\n8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedConnective{:¬}, SoleLogics.NamedConnective{:∧}, SoleLogics.NamedConnective{:∨}, SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:□}, SoleLogics.TopOperator}}:\n ¬\n ∧\n ∨\n →\n ◊\n □\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Home","title":"SoleLogics.bot","text":"bot(a::AbstractAlgebra)\n\nReturn the bottom of a given algebra.\n\nSee also top, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.box-Tuple{}","page":"Home","title":"SoleLogics.box","text":"box() = BOX\nbox(r::AbstractRelation) = BoxRelationalConnective(r)\n\nReturn either the box modal connective from unimodal logic (i.e., □), or a a box relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also BoxRelationalConnective, box, BOX.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.centralworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Home","title":"SoleLogics.centralworld","text":"Return the world at the center of the frame; note that this does not always exist.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.check","page":"Home","title":"SoleLogics.check","text":"function check(\n    φ::SyntaxTree,\n    i::AbstractKripkeStructure,\n    w::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing;\n    use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing,\n    perform_normalization::Bool = true,\n    memo_max_height::Union{Nothing,Int} = nothing,\n)::Bool\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Structure\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Home","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretationSet, Integer, Vararg{Any}}","page":"Home","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    i_instance::Integer,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on the i-th instance of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretationSet, Vararg{Any}}","page":"Home","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    args...;\n    kwargs...\n)::Vector{Bool}\n\nCheck a formula on all instances of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.cnf","page":"Home","title":"SoleLogics.cnf","text":"cnf(φ::Formula, literaltype = Literal; kwargs...)\n\nTODO docstring. Converts to cnf form ([`CNF`](@ref)).\n`CNF{literaltype}`\nAdditional `kwargs` are passed to [`normalize`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N","page":"Home","title":"SoleLogics.collatetruth","text":"collatetruth(c::Connective, ts::NTuple{N,T where T<:Truth})::Truth where {N}\n\nReturn the truth value for a composed formula c(t1, ..., tN), given the N with t1, ..., tN being Truth values.\n\nSee also simplify, Connective, Truth.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, Tuple{Vararg{var\"#s351\", N}} where var\"#s351\"<:(AbstractVector{W} where W<:AbstractWorld)}} where {N, W<:AbstractWorld}","page":"Home","title":"SoleLogics.collateworlds","text":"collateworlds(\n    fr::AbstractFrame{W},\n    op::Operator,\n    t::NTuple{N,WS},\n)::AbstractVector{<:W} where {N,W<:AbstractWorld,WS<:AbstractWorlds}\n\nFor a given crisp frame (truthtype == Bool), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the N sets of worlds where the each immediate sub-formula is true.\n\nSee also check, iscrisp, Operator, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, Tuple{Vararg{F, N}}}} where {N, F<:Formula}","page":"Home","title":"SoleLogics.composeformulas","text":"composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\n\nReturn a new formula of type F by composing N formulas of the same type via a connective c. This function allows one to use connectives for flexibly composing formulas (see Implementation section).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxBranch: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;) (see https://stackoverflow.com/a/60321302/5646732)\nSyntaxBranch: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxBranch: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon composeformulas lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (c::Connective)(φs::NTuple{N,Formula}) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of Formula, a new method for composeformulas should be defined, together with promotion from/to other Formulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective c, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nnote: Note\nTo allow for the composition of Formulas of different types, promotion rules should be provided.\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.connectives-Tuple{Formula}","page":"Home","title":"SoleLogics.connectives","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}","page":"Home","title":"SoleLogics.connectives","text":"connectives(g::AbstractGrammar)\n\nList all connectives appearing in a grammar.\n\nSee also Connective, nconnectives.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.converse-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.converse","text":"hasconverse(r::AbstractRelation)::Bool\nconverse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.diamond-Tuple{}","page":"Home","title":"SoleLogics.diamond","text":"diamond() = DIAMOND\ndiamond(r::AbstractRelation) = DiamondRelationalConnective(r)\n\nReturn either the diamond modal connective from unimodal logic (i.e., ◊), or a a diamond relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also DiamondRelationalConnective, diamond, DIAMOND.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}","page":"Home","title":"SoleLogics.domain","text":"domain(a::AbstractAlgebra)\n\nReturn an iterator to the values in the domain of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.dual-Tuple{SyntaxToken}","page":"Home","title":"SoleLogics.dual","text":"dual(tok::SyntaxToken)\n\nReturn the dual of a syntax token.\n\nIf tok is an Operator of arity n, the dual dtok is such that, on a Boolean algebra, tok(ch_1, ..., ch_n) ≡ ¬dtok(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q) (De Morgan's law). Duality also applies to operators with existential/universal semantics (◊/□), to Truth values (⊤/⊥), and to Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.emptyworld-Tuple{SoleLogics.AbstractMultiModalFrame}","page":"Home","title":"SoleLogics.emptyworld","text":"Return an empty world (e.g., Interval(-1,0)).\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar{V, O} where {V, O}}","page":"Home","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxBranch}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}","page":"Home","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{V,O} where {V,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxBranch}\n\nGenerate all formulas whose SyntaxBranchs that are not taller than a given maxdepth.\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.frame-Tuple{SoleLogics.AbstractKripkeStructure}","page":"Home","title":"SoleLogics.frame","text":"frame(i::AbstractKripkeStructure)::AbstractFrame\n\nReturn the frame of a Kripke structure.\n\nSee also AbstractFrame, AbstractKripkeStructure.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.goeswithdim-Tuple{AbstractWorld, Any}","page":"Home","title":"SoleLogics.goeswithdim","text":"Some worlds (dimensional worlds) can be interpreted on dimensional data, that is, n-dimensional arrays. The compatibility of a given world with respect of a  structure of a given dimensionality must be specified via the following trait:\n\ngoeswithdim(w::AbstractWorld, d) = goeswithdim(typeof(w), d)\ngoeswithdim(W::Type{<:AbstractWorld}, d::Integer) = goeswithdim(W, Val(d))\ngoeswithdim(::Type{<:AbstractWorld}, ::Val) = false\n\nExamples\n\njulia> SoleLogics.goeswithdim(OneWorld, 0)\ntrue\n\njulia> SoleLogics.goeswithdim(OneWorld, 1)\nfalse\n\njulia> SoleLogics.goeswithdim(Interval, 1)\ntrue\n\njulia> SoleLogics.goeswithdim(Interval, 2)\nfalse\n\njulia> all([SoleLogics.goeswithdim.(SoleLogics.Point{N}, N) for N in 1:10])\ntrue\n\n\nSee also OneWorld, World, Interval, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G","page":"Home","title":"SoleLogics.grammar","text":"grammar(l::AbstractLogic{G})::G where {G<:AbstractGrammar}\n\nReturn the grammar of a given logic.\n\nSee also AbstractGrammar, AbstractLogic, algebra, alphabet, formulas, grammar, operators, truthtype.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.hasconverse-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.hasconverse","text":"hasconverse(r::AbstractRelation)::Bool\nconverse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.hasdual-Tuple{SyntaxToken}","page":"Home","title":"SoleLogics.hasdual","text":"dual(tok::SyntaxToken)\n\nReturn the dual of a syntax token.\n\nIf tok is an Operator of arity n, the dual dtok is such that, on a Boolean algebra, tok(ch_1, ..., ch_n) ≡ ¬dtok(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q) (De Morgan's law). Duality also applies to operators with existential/universal semantics (◊/□), to Truth values (⊤/⊥), and to Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.height-Tuple{Formula}","page":"Home","title":"SoleLogics.height","text":"height(φ::Formula)::Integer\n\nReturn the height of a formula, in its syntax tree representation.\n\nSee also SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Home","title":"SoleLogics.interpret","text":"interpret(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Formula\n\nReturn the truth value for a formula on a logical interpretation (or model).\n\nExamples\n\njulia> @atoms p q\n2-element Vector{Atom{String}}:\n p\n q\n\njulia> td = TruthDict([p => true, q => false])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> interpret(CONJUNCTION(p,q), td)\n⊥\n\nSee also check, Formula, AbstractInterpretation, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.isbot-Tuple{Truth}","page":"Home","title":"SoleLogics.isbot","text":"isbot(::Truth)::Bool\n\nReturn true if the Truth value is the bottom of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nisbot(t::Bool)::Bool = (t == false)\n\nSee also istop, Truth.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.isbox-Tuple{Any}","page":"Home","title":"SoleLogics.isbox","text":"isbox(::Type{<:Connective})::Bool = false\nisbox(c::Connective)::Bool = isbox(typeof(c))\n\nReturn whether it is known that an Connective is a box (i.e., universal) connective.\n\nExamples\n\njulia> SoleLogics.isbox(◊)\nfalse\n\njulia> SoleLogics.isbox(∧)\nfalse\n\njulia> SoleLogics.isbox(□)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.iscommutative-Tuple{Connective}","page":"Home","title":"SoleLogics.iscommutative","text":"iscommutative(c::Connective)\n\nReturn whether a connective is known to be commutative.\n\nExamples\n\njulia> iscommutative(∧)\ntrue\n\njulia> iscommutative(→)\nfalse\n\nNote that nullary and unary connectives are considered commutative.\n\nSee also Connective.\n\nImplementation\n\nWhen implementing a new type for a commutative connective C with arity higher than 1, please provide a method iscommutative(::C). This can help model checking operations.\n\nSee also Connective.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}","page":"Home","title":"SoleLogics.iscrisp","text":"iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))\n\nAn algebra is crisp (or boolean) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is fuzzy.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.isgrounded-Tuple{Formula}","page":"Home","title":"SoleLogics.isgrounded","text":"isgrounded(f::Formula)::Bool\n\nReturn true if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.\n\nExamples\n\njulia> f = parseformula(\"⟨G⟩p → [G]q\");\n\njulia> syntaxstring(f)\n\"(⟨G⟩p) → ([G]q)\"\n\njulia> SoleLogics.isgrounded(f)\ntrue\n\nSee also isgrounding), SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.isgrounding-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.isgrounding","text":"isgrounding(::AbstractRelation)\n\nReturn whether it is known that a relation is grounding. A relation R is grounding if ∀x,z,y R(x,y) ⇔ R(z,y).\n\nSee also isreflexive, issymmetric, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.ismodal-Tuple{Type{<:Connective}}","page":"Home","title":"SoleLogics.ismodal","text":"ismodal(::Type{<:Connective})::Bool = false\nismodal(c::Connective)::Bool = ismodal(typeof(c))\n\nReturn whether it is known that an Connective is modal.\n\nExamples\n\njulia> ismodal(◊)\ntrue\n\njulia> ismodal(∧)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.isreflexive-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.isreflexive","text":"isreflexive(::AbstractRelation)\n\nReturn whether it is known that a relation is reflexive.\n\nSee also issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.issymmetric-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.issymmetric","text":"issymmetric(r::AbstractRelation) = hasconverse(r) ? converse(r) == r : false\n\nReturn whether it is known that a relation is symmetric.\n\nSee also hasconverse, converse, isreflexive, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.istoone-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.istoone","text":"istoone(r::AbstractRelation) = false\n\nReturn whether it is known that a relation is istoone.\n\nSee also hasconverse, converse, issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.istop-Tuple{Truth}","page":"Home","title":"SoleLogics.istop","text":"istop(::Truth)::Bool\n\nReturn true if the Truth value is the top of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nistop(t::Bool)::Bool = (t == true)\n\nSee also isbot, Truth.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.istopological-Tuple{SoleLogics.GeometricalRelation}","page":"Home","title":"SoleLogics.istopological","text":"istopological(r::GeometricalRelation)\n\nReturn whether it is known that a given geometrical relation is topological (i.e., invariant under homeomorphisms,  see here)\n\nSee also GeometricalRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.istransitive-Tuple{AbstractRelation}","page":"Home","title":"SoleLogics.istransitive","text":"istransitive(::AbstractRelation)\n\nReturn whether it is known that a relation is transitive.\n\nSee also istoone, issymmetric, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.leaves-Tuple{Formula}","page":"Home","title":"SoleLogics.leaves","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}","page":"Home","title":"SoleLogics.leaves","text":"leaves(g::AbstractGrammar)\n\nList all leaves appearing in a grammar.\n\nSee also SyntaxLeaf, nleaves.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.logic-Tuple{AnchoredFormula}","page":"Home","title":"SoleLogics.logic","text":"logic(φ::AnchoredFormula)::AbstractLogic\n\nReturn the logic of an anchored formula\n\nSee AnchoredFormula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.modallogic-Tuple{}","page":"Home","title":"SoleLogics.modallogic","text":"modallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a modal logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic(; operators = [¬, ∨]))\n┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedConnective[¬, ∨]). Consider using propositionallogic instead.\n└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642\nfalse\n\njulia> modallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> modallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also propositionallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.natoms-Tuple{Formula}","page":"Home","title":"SoleLogics.natoms","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Home","title":"SoleLogics.natoms","text":"natoms(a::AbstractAlphabet)::Integer\n\nReturn the number of atoms of a finite alphabet.\n\nSee also randatom, AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.nconnectives-Tuple{Formula}","page":"Home","title":"SoleLogics.nconnectives","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.nleaves-Tuple{Formula}","page":"Home","title":"SoleLogics.nleaves","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.noperators-Tuple{Formula}","page":"Home","title":"SoleLogics.noperators","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.normalize-Tuple{Formula, Vararg{Any}}","page":"Home","title":"SoleLogics.normalize","text":"normalize(\n    f::Formula;\n    profile = :readability,\n    remove_boxes = nothing,\n    reduce_negations = true,\n    simplify_constants = true,\n    allow_atom_flipping = false,\n    prefer_implications = false,\n    remove_implications = false,\n    forced_negation_removal = nothing,\n    remove_identities = true,\n    unify_toones = true,\n    rotate_commutatives = true,\n)\n\nReturn a modified version of a given formula, that has the same semantics but different syntax. This is useful for simplifying formulas for readability, or when checking the truth of many (possibly semantically similar) formulas; for example, when performing model checking. The current implementation assumes the underlying algebra is Boolean!\n\nArguments\n\nf::Formula: when set to true,   the formula;\nprofile::Symbol: possible values are :readability, which optimizes for qualitative   simplicity for a human to understand, and :modelchecking, which optimizes   model checking speed;\nremove_boxes::Bool: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.\nreduce_negations::Bool: when set to true,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., De Morgan's laws).   Note: this assumes an underlying Boolean algebra.\nallow_atom_flipping::Bool: when set to true,   together with reduce_negations=true, this may cause the negation of an atom   to be replaced with the its dual atom.\n\nExamples\n\njulia> f = parseformula(\"□¬((p∧¬q)→r)∧⊤\");\n\njulia> syntaxstring(f)\n\"□¬((p ∧ ¬q) → r) ∧ ⊤\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))\n\"¬◊(q ∨ ¬p ∨ r)\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))\n\"□(¬r ∧ p ∧ ¬q)\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.ntokens-Tuple{Formula}","page":"Home","title":"SoleLogics.ntokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.ntruths-Tuple{Formula}","page":"Home","title":"SoleLogics.ntruths","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}","page":"Home","title":"SoleLogics.nworlds","text":"nworlds(fr::AbstractFrame)::Integer\n\nReturn the number of worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.operators-Tuple{Formula}","page":"Home","title":"SoleLogics.operators","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.parsebaseformula-Tuple{String, Vararg{Any}}","page":"Home","title":"SoleLogics.parsebaseformula","text":"parsebaseformula(\n    expr::String,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing;\n    operators::Union{Nothing,Vector{<:Operator}},\n    grammar::Union{Nothing,AbstractGrammar} = nothing,\n    algebra::Union{Nothing,AbstractAlgebra} = nothing,\n    kwargs...\n)::AnchoredFormula\n\nReturn a AnchoredFormula which is the result of parsing an expression via the Shunting yard algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES; additional operators may be provided as a second argument.\n\nThe grammar and algebra of the associated logic is inferred using the baseformula function from the operators encountered in the expression, and those in additional_operators.\n\nSee parseformula, baseformula, BASE_PARSABLE_CONNECTIVES.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.parseformula","page":"Home","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\n\nparseformula(\n    F::Type{<:SyntaxTree},\n    expr::String,\n    additional_operators::Union{Nothing,AbstractVector} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)::F\n\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstrings will be used for parsing them. Note that, in case of clashing syntaxstrings, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, BASE_PARSABLE_CONNECTIVES, syntaxstring.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.parseformula-Tuple{Type{<:Formula}, String, Vararg{Any}}","page":"Home","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\n\nparseformula(\n    F::Type{<:SyntaxTree},\n    expr::String,\n    additional_operators::Union{Nothing,AbstractVector} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)::F\n\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstrings will be used for parsing them. Note that, in case of clashing syntaxstrings, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, BASE_PARSABLE_CONNECTIVES, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.parseformula-Tuple{Type{<:SyntaxTree}, String, SoleLogics.AbstractGrammar}","page":"Home","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\n\nparseformula(\n    F::Type{<:SyntaxTree},\n    expr::String,\n    additional_operators::Union{Nothing,AbstractVector} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)::F\n\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstrings will be used for parsing them. Note that, in case of clashing syntaxstrings, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, BASE_PARSABLE_CONNECTIVES, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.parseformula-Tuple{Type{<:SyntaxTree}, String, SoleLogics.AbstractLogic}","page":"Home","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\n\nparseformula(\n    F::Type{<:SyntaxTree},\n    expr::String,\n    additional_operators::Union{Nothing,AbstractVector} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)::F\n\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstrings will be used for parsing them. Note that, in case of clashing syntaxstrings, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, BASE_PARSABLE_CONNECTIVES, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.precedence-Tuple{Connective}","page":"Home","title":"SoleLogics.precedence","text":"precedence(c::Connective)\n\nReturn the precedence of a binary connective.\n\nWhen using infix notation, and in the absence of parentheses, precedence establishes how binary connectives are interpreted. A precedence value is a standard integer, and connectives with high precedence take precedence over connectives with lower precedences. This affects how formulas are shown (via syntaxstring) and parsed (via parseformula).\n\nBy default, the value for a NamedConnective is derived from the Base.operator_precedence of its symbol (name); there are some exceptions (e.g., ¬). Because of this, when dealing with a custom connective ⊙, it will be the case that parseformula(\"p ⊙ q ∧ r\") == (@synexpr p ⊙ q ∧ r).\n\nIt is possible to assign a specific precedence to a connective type C by providing a method Base.operator_precedence(::C).\n\nExamples\n\njulia> precedence(∧) == Base.operator_precedence(:∧)\ntrue\n\njulia> precedence(∧), precedence(∨), precedence(→)\n∨(12, 11, 4)\n\njulia> syntaxstring(parseformula(\"¬a ∧ b ∧ c\"))\n\"¬a ∧ b ∧ c\"\n\njulia> syntaxstring(parseformula(\"¬a → b ∧ c\"))\n\"(¬a) → (b ∧ c)\"\n\njulia> syntaxstring(parseformula(\"a ∧ b → c ∧ d\"))\n\"(a ∧ b) → (c ∧ d)\"\n\nSee also associativity, Connective.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.precedes-Tuple{Truth, Truth}","page":"Home","title":"SoleLogics.precedes","text":"TODO docstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.propositionallogic-Tuple{}","page":"Home","title":"SoleLogics.propositionallogic","text":"propositionallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = NamedConnective[¬, ∧, ∨, →],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), NamedConnective[¬, ∧, ∨, →]),\n    algebra = BooleanAlgebra()\n)\n\nInstantiate a propositional logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(propositionallogic())\ntrue\n\njulia> (¬) isa operatorstype(propositionallogic(; operators = [∨]))\nfalse\n\njulia> propositionallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> propositionallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also modallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randatom-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}","page":"Home","title":"SoleLogics.randatom","text":"randatom(a::AbstractAlphabet)\nrandatom(rng, a::AbstractAlphabet)\n\nReturn a random atom from a finite alphabet.\n\nSee also natoms, AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randatom-Tuple{Union{Integer, Random.AbstractRNG}, UnionAlphabet}","page":"Home","title":"SoleLogics.randatom","text":"randatom(\n    rng::Union{Integer,AbstractRNG},\n    a::UnionAlphabet;\n    atompicking_mode::Symbol=:uniform,\n    subalphabets_weights::Union{AbstractWeights,AbstractVector{<:Real},Nothing} = nothing\n)::Atom\n\nSample an atom from a UnionAlphabet. By default, the sampling is uniform with respect to the atoms. However, by setting atompicking_mode = :uniform_subalphabets one can force a uniform sampling with respect to the sub-alphabets. Moreover, one can specify a :weighted atompicking_mode, together with a subalphabets_weights vector.\n\nSee also UnionAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randbaseformula-Tuple{Integer, SoleLogics.AbstractGrammar}","page":"Home","title":"SoleLogics.randbaseformula","text":"randformula(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG, ]\n    height::Integer,\n    alphabet,\n    operators::AbstractVector;\n    kwargs...\n)::SyntaxTree\n\nrandformula(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG, ]\n    height::Integer,\n    g::AbstractGrammar;\n    kwargs...\n)::SyntaxTree\n\nReturn a pseudo-randomic SyntaxTree.\n\nArguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::AbstractVector: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately. (TODO explain?)\n\nKeyword Arguments\n\nmodaldepth::Integer: maximum modal depth\natompicker::Function: method used to pick a random element. For example, this could be   Base.rand or StatsBase.sample.\nopweights::AbstractWeights: weight vector over the set of operators (see StatsBase).\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randformula-Tuple{Union{Integer, Random.AbstractRNG}, Integer, Union{SoleLogics.AbstractAlphabet, AbstractVector}, AbstractVector}","page":"Home","title":"SoleLogics.randformula","text":"randformula(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG, ]\n    height::Integer,\n    alphabet,\n    operators::AbstractVector;\n    kwargs...\n)::SyntaxTree\n\nrandformula(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG, ]\n    height::Integer,\n    g::AbstractGrammar;\n    kwargs...\n)::SyntaxTree\n\nReturn a pseudo-randomic SyntaxTree.\n\nArguments\n\nrng::Union{Intger,AbstractRNG} = Random.GLOBAL_RNG: random number generator;\nheight::Integer: height of the generated structure;\nalphabet::AbstractAlphabet: collection from which atoms are chosen randomly;\noperators::AbstractVector: vector from which legal operators are chosen;\ng::AbstractGrammar: alternative to passing alphabet and operators separately. (TODO explain?)\n\nKeyword Arguments\n\nmodaldepth::Integer: maximum modal depth\natompicker::Function: method used to pick a random element. For example, this could be   Base.rand or StatsBase.sample.\nopweights::AbstractWeights: weight vector over the set of operators (see StatsBase).\n\nExamples\n\njulia> syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))\n\"¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))\"\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randframe-Tuple{Int64, Int64}","page":"Home","title":"SoleLogics.randframe","text":"function randframe(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG,]\n    nworlds::Int64,\n    nedges::Int64,\n    facts::Vector{SyntaxLeaf}\nend\n\nReturn a random Kripke Frame, which is a directed graph interpreted as a SoleLogics.ExplicitCrispUniModalFrame. The underlying graph is generated using Graphs.SimpleGraphs.SimpleDiGraph.\n\nArguments:\n\nrng is a random number generator, or the seed used to create one;\nnworld is the number of worlds (nodes) in the frame. Worlds are numbered from 1   to nworld included.\nnedges is the number of relations (edges) in the frame;\nfacts is a vector of generic SyntaxLeaf.\n\nSee also SyntaxLeaf, Graphs.SimpleGraphs.SimpleDiGraph, SoleLogics.ExplicitCrispUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.randmodel","page":"Home","title":"SoleLogics.randmodel","text":"function randmodel(\n    [rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG,]\n    nworlds::Int64,\n    nedges::Int64,\n    facts::Vector{SyntaxLeaf};\n    truthvalues::Union{AbstractAlgebra,AbstractVector{<:Truth}} = BooleanAlgebra();\n    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG\n)\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.relation-Tuple{SoleLogics.AbstractRelationalConnective}","page":"Home","title":"SoleLogics.relation","text":"relationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalConnective) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational connective.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.relationtype-Union{Tuple{SoleLogics.AbstractRelationalConnective{R}}, Tuple{R}} where R<:AbstractRelation","page":"Home","title":"SoleLogics.relationtype","text":"relationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalConnective) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational connective.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N","page":"Home","title":"SoleLogics.simplify","text":"simplify(c::Connective, ts::NTuple{N,F where F<:Formula})::Truth where {N}\n\nReturn a formula with the same semantics of a composed formula c(φ1, ..., φN), given the N immediate sub-formulas.\n\nSee also collatetruth, Connective, Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.subformulas-Tuple{Formula, Vararg{Any}}","page":"Home","title":"SoleLogics.subformulas","text":"subformulas(f::Formula; sorted=true)\n\nReturn all sub-formulas (sorted by size when sorted=true) of a given formula.\n\nExamples\n\njulia> syntaxstring.(SoleLogics.subformulas(parseformula(\"◊((p∧q)→r)\")))\n6-element Vector{String}:\n \"p\"\n \"q\"\n \"r\"\n \"p ∧ q\"\n \"◊(p ∧ q)\"\n \"(◊(p ∧ q)) → r\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.synstruct-Tuple{AnchoredFormula}","page":"Home","title":"SoleLogics.synstruct","text":"synstruct(φ::AnchoredFormula)::AbstractSyntaxStructure\n\nReturn the syntactic component of an anchored formula.\n\nSee AnchoredFormula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.syntaxstring-Tuple{Syntactical}","page":"Home","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.token-Tuple{SyntaxTree}","page":"Home","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nReturn the token at the root of a syntax tree.\n\nSee also SyntaxBranch, SyntaxLeaf.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.tokens-Tuple{Formula}","page":"Home","title":"SoleLogics.tokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Home","title":"SoleLogics.top","text":"top(a::AbstractAlgebra)\n\nReturn the top of a given algebra.\n\nSee also bot, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.tree-Tuple{Formula}","page":"Home","title":"SoleLogics.tree","text":"tree(φ::Formula)::SyntaxTree\n\nReturn the SyntaxTree representation of a formula; note that this is equivalent to Base.convert(SyntaxTree, φ).\n\nSee also Formula, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}","page":"Home","title":"SoleLogics.treewalk","text":"treewalk(\n    st::SyntaxTree,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    criterion::Function = ntokens,\n    toleaf::Bool = true,\n    returnnode::Bool = false,\n    transformnode::Function = nothing\n)::SyntaxTree\n\nReturn a subtree of syntax tree, by following these options:\n\ncriterion: function used to compute the probability of stopping at a random node;\nreturnnode: true if only the subtree is to be returned;\ntransformnode: function that will be applied to the chosen subtree.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.truths-Tuple{Formula}","page":"Home","title":"SoleLogics.truths","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T<:Truth","page":"Home","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth} = T\ntruthtype(a::AbstractAlgebra) = truthtype(typeof(a))\n\nThe Julia type for representing truth values of the algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W<:AbstractWorld","page":"Home","title":"SoleLogics.worldtype","text":"worldtype(fr::AbstractFrame)\nworldtype(i::AbstractKripkeStructure)\n\nReturn the world type of the Kripke frame/structure.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#StatsBase.sample","page":"Home","title":"StatsBase.sample","text":"function StatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    alphabet::AbstractAlphabet,\n    weights::AbstractWeights,\n    args...;\n    kwargs...\n)\n\nfunction StatsBase.sample(\n    rng::AbstractRNG,\n    l::AbstractLogic,\n    weights::AbstractWeights,\n    args...;\n    kwargs...\n)\n\nStatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    height::Integer,\n    g::AbstractGrammar,\n    [opweights::Union{Nothing,AbstractWeights} = nothing,]\n    args...;\n    kwargs...\n)::Formula\n\nRandomly sample an Atom from an alphabet, or a logic formula of given height from a grammar g. Sampling is weighted, thus, for example, if the first weight in weights is higher than the others, then the first atom in the alphabet is selected more frequently.\n\nSee also AbstractAlphabet, AbstractWeights, Atom.\n\n\n\n\n\n","category":"function"},{"location":"#StatsBase.sample-2","page":"Home","title":"StatsBase.sample","text":"function StatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    alphabet::AbstractAlphabet,\n    weights::AbstractWeights,\n    args...;\n    kwargs...\n)\n\nfunction StatsBase.sample(\n    rng::AbstractRNG,\n    l::AbstractLogic,\n    weights::AbstractWeights,\n    args...;\n    kwargs...\n)\n\nStatsBase.sample(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    height::Integer,\n    g::AbstractGrammar,\n    [opweights::Union{Nothing,AbstractWeights} = nothing,]\n    args...;\n    kwargs...\n)::Formula\n\nRandomly sample an Atom from an alphabet, or a logic formula of given height from a grammar g. Sampling is weighted, thus, for example, if the first weight in weights is higher than the others, then the first atom in the alphabet is selected more frequently.\n\nSee also AbstractAlphabet, AbstractWeights, Atom.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.@atoms-Tuple","page":"Home","title":"SoleLogics.@atoms","text":"@atoms(ps...)\n\nInstantiate a collection of Atoms and return them as a vector.\n\ninfo: Info\nAtoms instantiated with this macro are defined in the global scope as constants.\n\nExamples\n\njulia> SoleLogics.@atoms String p q r s\n4-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n Atom{String}(\"r\")\n Atom{String}(\"s\")\n\njulia> p\nAtom{String}(\"p\")\n\n\n\n\n\n","category":"macro"},{"location":"#SoleLogics.@synexpr-Tuple{Any}","page":"Home","title":"SoleLogics.@synexpr","text":"@synexpr(expression)\n\nReturn an expression after automatically instantiating undefined Atoms.\n\ninfo: Info\n\n\nAll atoms are parsed as Atom{String} objects.\n\nwarning: Warning\n\n\nThe Julia parser can parse some (infix) NamedConnectives such as ∧, →, but has a few limitations, including:\n\ninexact precedence and associativity for some operators (e.g.,   in fact, as of Julia 1.9, despite (@synexpr ¬ p ∧ q) == @synexpr ¬(p) ∧ q,   Base.operatorprecedence(:(¬)) < Base.operatorprecedence(:(∧)));\ninability to parse most multi-character, custom-made Connectives (e.g., ⟨=⟩, [G]);\n\nFor a more flexible parsing, consider using parseformula.\n\nExamples\n\njulia> @synexpr x = p # Atom{String}(\"p\") is assigned to the global variable x\nAtom{String}(\"p\")\n\njulia> @synexpr st = p ∧ q → r\n(p ∧ q) → r\n\njulia> token(st)\n→\n\nSee also parseformula, Atom, Connective, precedence, associativity.\n\n\n\n\n\n","category":"macro"},{"location":"#SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","page":"Home","title":"SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","text":"Syntaxstring aliases for standard features, such as \"min\", \"max\", \"avg\".\n\n\n\n\n\n","category":"constant"},{"location":"#SoleData.AbstractCondition","page":"Home","title":"SoleData.AbstractCondition","text":"abstract type AbstractCondition{FT<:AbstractFeature} end\n\nAbstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into Atoms.\n\nSee also Atom, syntaxstring, ScalarMetaCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractFeature","page":"Home","title":"SoleData.AbstractFeature","text":"abstract type AbstractFeature end\n\nAbstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripkestructure(model_checking).\n\nSee also VarFeature, featvaltype, SoleLogics.AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractFullMemoset","page":"Home","title":"SoleData.AbstractFullMemoset","text":"Abstract type for full memoization structures for checking generic formulas.\n\nThese structures can be stacked and coupled with one-step memoization structures (see SupportedLogiset).\n\nSee AbstractOneStepMemoset, FullMemoset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractMemoset","page":"Home","title":"SoleData.AbstractMemoset","text":"abstract type AbstractMemoset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame,\n} <: AbstractModalLogiset{W,U,FT,FR} end\n\nAbstract type for memoization structures to be used when checking formulas on logisets.\n\nSee also FullMemoset, SupportedLogiset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractModalLogiset","page":"Home","title":"SoleData.AbstractModalLogiset","text":"abstract type AbstractModalLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractLogiset end\n\nAbstract type for logisets, that is, logical datasets for symbolic learning where each instance is a Kripke structure associating feature values to each world. Conditions (see AbstractCondition), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.\n\nSee also AbstractCondition, AbstractFeature, SoleLogics.AbstractKripkeStructure, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractOneStepMemoset","page":"Home","title":"SoleData.AbstractOneStepMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩p; with these formulas, so-called \"one-step\" optimizations can be performed.\n\nThese structures can be stacked and coupled with full memoization structures (see SupportedLogiset).\n\nSee ScalarOneStepMemoset, AbstractFullMemoset, representatives.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractScalarOneStepGlobalMemoset","page":"Home","title":"SoleData.AbstractScalarOneStepGlobalMemoset","text":"Abstract type for one-step memoization structure for checking \"global\" formulas of type ⟨G⟩ (f ⋈ t).     We refer to these structures as global memosets.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractScalarOneStepRelationalMemoset","page":"Home","title":"SoleData.AbstractScalarOneStepRelationalMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩ (f ⋈ t), for a generic relation R that is not the global relation (SoleLogics.globalrel). We refer to these structures as relational memosets.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractUnivariateFeature","page":"Home","title":"SoleData.AbstractUnivariateFeature","text":"abstract type AbstractUnivariateFeature <: VarFeature end\n\nA dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, UnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.Aggregator","page":"Home","title":"SoleData.Aggregator","text":"const Aggregator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also ScalarCondition, ScalarOneStepMemoset, TestOperator.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExistentialTopFormula","page":"Home","title":"SoleData.ExistentialTopFormula","text":"Templated formula for ⟨R⟩⊤.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExplicitBooleanModalLogiset","page":"Home","title":"SoleData.ExplicitBooleanModalLogiset","text":"struct ExplicitBooleanModalLogiset{\n    W<:AbstractWorld,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractModalLogiset{W,Bool,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Vector{FT}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExplicitFeature","page":"Home","title":"SoleData.ExplicitFeature","text":"struct ExplicitFeature{T} <: AbstractFeature\n    name::String\n    featstruct\nend\n\nA feature encoded explicitly, for example, as a slice of DimensionalDatasets.UniformFullDimensionalLogiset's feature structure.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExplicitModalLogiset","page":"Home","title":"SoleData.ExplicitModalLogiset","text":"struct ExplicitModalLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractModalLogiset{W,U,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Dict{FT,U}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.Feature","page":"Home","title":"SoleData.Feature","text":"struct Feature{A} <: AbstractFeature\n    atom::A\nend\n\nA feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.FullMemoset","page":"Home","title":"SoleData.FullMemoset","text":"A generic, full memoization structure that works for any crisp logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.\n\nSee also SupportedLogiset, AbstractMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.FunctionalCondition","page":"Home","title":"SoleData.FunctionalCondition","text":"struct FunctionalCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\n    f::FT\nend\n\nA condition which yields a truth value equal to the value of a function.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultiFormula","page":"Home","title":"SoleData.MultiFormula","text":"struct MultiFormula{F<:Formula} <: AbstractSyntaxStructure\n    modforms::Dict{Int,F}\nend\n\nA symbolic antecedent that can be checked on a MultiLogiset, associating antecedents to modalities.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultiLogiset","page":"Home","title":"SoleData.MultiLogiset","text":"struct MultiLogiset{L<:AbstractLogiset}\n    modalities  :: Vector{L}\nend\n\nA logical dataset composed of different modalities); this structure is useful for representing multimodal datasets in logical terms.\n\nSee also AbstractLogiset, minify.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultivariateFeature","page":"Home","title":"SoleData.MultivariateFeature","text":"struct MultivariateFeature{U} <: VarFeature\n    f::Function\nend\n\nA dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a Interval2D world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and \"resembling a horse\" may require a computation involving all variables.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ObliqueScalarCondition","page":"Home","title":"SoleData.ObliqueScalarCondition","text":"ObliqueScalarCondition(features, b, u, test_operator)\n\nAn oblique scalar condition (see oblique decision trees), such as ((features - b)  u)  0, where features is a set of m features, and bu  ℝ^m.\n\nSee also AbstractCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.PropositionalLogiset","page":"Home","title":"SoleData.PropositionalLogiset","text":"PropositionalLogiset(table)\n\nA logiset of propositional interpretations, wrapping a Tables' table of real/string/categorical values.\n\nExamples\n\nThis structure can be used to check propositional formulas:\n\nusing SoleData, MLJBase\n\nX = PropositionalLogiset(MLJBase.load_iris())\n\nφ = parseformula(\n    \"sepal_length > 5.8 ∧ sepal_width < 3.0 ∨ target == \"setosa\"\";\n    atom_parser = a->Atom(parsecondition(SoleData.ScalarCondition, a; featuretype = SoleData.VariableValue))\n)\n\ncheck(φ, X, 10) # Check the formula on a single instance\n\nsatmask = check(φ, X) # Check the formula on the whole dataset\n\nslicedataset(X, satmask)\nslicedataset(X, (!).(satmask))\n\nSee also AbstractLogiset, AbstractAssignment.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarChainedMemoset","page":"Home","title":"SoleData.ScalarChainedMemoset","text":"A full memoization structure used for checking formulas of scalar conditions on datasets with scalar features. This structure is the equivalent to FullMemoset, but with scalar features some important optimizations can be done.\n\nSee also FullMemoset, SupportedLogiset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarCondition","page":"Home","title":"SoleData.ScalarCondition","text":"struct ScalarCondition{U,FT<:AbstractFeature,M<:ScalarMetaCondition{FT}} <: AbstractCondition{FT}\n    metacond::M\n    a::U\nend\n\nA scalar condition comparing a computed feature value (see ScalarMetaCondition) and a threshold value a. It can be evaluated on a world of an instance of a logical dataset.\n\nFor example: minV1  10, which translates to \"Within this world, the minimum of variable 1 is greater or equal than 10.\" In this case, the feature a VariableMin object.\n\nSee also AbstractCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarExistentialFormula","page":"Home","title":"SoleData.ScalarExistentialFormula","text":"Templated formula for ⟨R⟩ f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarFormula","page":"Home","title":"SoleData.ScalarFormula","text":"Abstract type for templated formulas on scalar conditions.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarMetaCondition","page":"Home","title":"SoleData.ScalarMetaCondition","text":"struct ScalarMetaCondition{FT<:AbstractFeature,O<:TestOperator} <: AbstractCondition{FT}\n    feature::FT\n    test_operator::O\nend\n\nA metacondition representing a scalar comparison method. Here, the feature is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see ScalarCondition). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see UnboundedScalarAlphabet): minV1  a a  ℝ.\n\nSee also AbstractCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarOneStepMemoset","page":"Home","title":"SoleData.ScalarOneStepMemoset","text":"One-step memoization structures for optimized check of formulas of type ⟨R⟩p, where p wraps a scalar condition, such as MyFeature ≥ 10. With such formulas, scalar one-step optimization can be performed.\n\nFor example, checking ⟨R⟩(MyFeature ≥ 10) on a world w of a Kripke structure involves comparing the maximum MyFeature across ws accessible worlds with 10; but the same maximum value can be reused to check sibling formulas such as ⟨R⟩(MyFeature ≥ 100). This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type ⟨R⟩(f ⋈ ?), called a \"scalar metacondition\".\n\nSimilar cases arise depending on the relation and the test operator (or, better, its aggregator), and further optimizations can be applied for specific feature types (see representatives).\n\nAn immediate special case, however, arises when R is the global relation G since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, relational memosets (see AbstractScalarOneStepRelationalMemoset), and global memosets (see AbstractScalarOneStepGlobalMemoset), which are usually much smaller.\n\nGiven a logiset X, a ScalarOneStepMemoset covers a set of relations and metaconditions, and it holds both a relational and a global memoset. It can be instantiated via:\n\nScalarOneStepMemoset(\n    X                       :: AbstractModalLogiset{W,U},\n    metaconditions          :: AbstractVector{<:ScalarMetaCondition},\n    relations               :: AbstractVector{<:AbstractRelation};\n    precompute_globmemoset  :: Bool = true,\n    precompute_relmemoset   :: Bool = false,\n    print_progress          :: Bool = false,\n)\n\nIf precompute_relmemoset is false, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. precompute_globmemoset works similarly.\n\nSee SupportedLogiset, ScalarMetaCondition, AbstractOneStepMemoset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarOneStepRelationalMemoset","page":"Home","title":"SoleData.ScalarOneStepRelationalMemoset","text":"A generic, one-step memoization structure used for checking specific formulas of scalar conditions on datasets with scalar features. The formulas are of type ⟨R⟩ (f ⋈ t)\n\nSee also AbstractScalarOneStepRelationalMemoset, FullMemoset, SupportedLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarUniversalFormula","page":"Home","title":"SoleData.ScalarUniversalFormula","text":"Templated formula for [R] f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.SupportedLogiset","page":"Home","title":"SoleData.SupportedLogiset","text":"A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.\n\nSee also SupportedLogiset, AbstractFullMemoset, AbstractOneStepMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.TestOperator","page":"Home","title":"SoleData.TestOperator","text":"const TestOperator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also Aggregator, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateFeature","page":"Home","title":"SoleData.UnivariateFeature","text":"struct UnivariateFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    f::Function\nend\n\nA dimensional feature represented by the application of a generic function f to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateNamedFeature","page":"Home","title":"SoleData.UnivariateNamedFeature","text":"struct UnivariateNamedFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    name::String\nend\n\nA univariate feature solely identified by its name and reference variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateScalarAlphabet","page":"Home","title":"SoleData.UnivariateScalarAlphabet","text":"struct UnivariateScalarAlphabet <: AbstractAlphabet{ScalarCondition}\n    featcondition::Vector{UnivariateScalarAlphabet}\nend\n\nA finite alphabet of conditions, grouped by (a finite set of) metaconditions.\n\nSee also UnboundedScalarAlphabet, ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UniversalBotFormula","page":"Home","title":"SoleData.UniversalBotFormula","text":"Templated formula for [R]⊥.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ValueCondition","page":"Home","title":"SoleData.ValueCondition","text":"struct ValueCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\nend\n\nA condition which yields a truth value equal to the value of a feature.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VarFeature","page":"Home","title":"SoleData.VarFeature","text":"abstract type VarFeature <: AbstractFeature end\n\nAbstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of variables, which can be used to define logical features.\n\nFor example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a `SoleLogics.GeometricalWorld).\n\nAs an example of a dimensional feature, consider min[V1], which computes the minimum for variable 1 for a given world. ScalarConditions such as min[V1] >= 10 can be, then, evaluated on worlds.\n\nSee also scalarlogiset, featvaltype, computefeature, SoleLogics.Interval.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMax","page":"Home","title":"SoleData.VariableMax","text":"struct VariableMax <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMin","page":"Home","title":"SoleData.VariableMin","text":"struct VariableMin <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMax","page":"Home","title":"SoleData.VariableSoftMax","text":"struct VariableSoftMax{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMin","page":"Home","title":"SoleData.VariableSoftMin","text":"struct VariableSoftMin{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableValue","page":"Home","title":"SoleData.VariableValue","text":"struct VariableValue <: AbstractUnivariateFeature\n    i_variable::Union{Integer,Symbol}\nend\n\nA simple feature, equal the value of a scalar variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}","page":"Home","title":"SoleData.apply_test_operator","text":"Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.computefeature-Tuple{VarFeature, Any}","page":"Home","title":"SoleData.computefeature","text":"computefeature(f::VarFeature, featchannel; kwargs...)\n\nCompute a feature on a featchannel (i.e., world reading) of an instance.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}","page":"Home","title":"SoleData.computeunivariatefeature","text":"computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)\n\nCompute a feature on a variable channel (i.e., world reading) of an instance.\n\nSee also AbstractUnivariateFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.featvaltype-Tuple{Any, VarFeature}","page":"Home","title":"SoleData.featvaltype","text":"featvaltype(dataset, f::VarFeature)\n\nReturn the type of the values returned by feature f on logiseed dataset.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.isminifiable-Tuple{Any}","page":"Home","title":"SoleData.isminifiable","text":"isminifiable(::Any)::Bool\n\nReturn whether minification can be applied on a dataset structure. See also minify.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Union{Missing, Nothing, Real}","page":"Home","title":"SoleData.minify","text":"minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}\n\nReturn a minified version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.\n\nSee also isminifiable.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"SoleData.naturalgrouping","text":"naturalgrouping(\n    X::AbstractDataFrame;\n    allow_variable_drop = false,\n)::AbstractVector{<:AbstractVector{<:Symbol}}\n\nReturn variables grouped by their logical nature; the nature of a variable is automatically derived from its type (e.g., Real, Vector{<:Real} or Matrix{<:Real}) and frame. All instances must have the same frame (e.g., channel size/number of worlds).\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsecondition-Tuple{Type{<:SoleData.AbstractCondition}, String}","page":"Home","title":"SoleData.parsecondition","text":"parsecondition(C::Type{<:AbstractCondition}, expr::String; kwargs...)\n\nParse a condition of type C from its syntaxstring representation. Depending on C, specifying keyword arguments such as featuretype::Type{<:AbstractFeature}, and featvaltype::Type may be required or recommended.\n\nSee also parsefeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsefeature-Tuple{Type{<:AbstractFeature}, String}","page":"Home","title":"SoleData.parsefeature","text":"parsefeature(FT::Type{<:AbstractFeature}, expr::String; kwargs...)\n\nParse a feature of type FT from its syntaxstring representation. Depending on FT, specifying keyword arguments such as featvaltype::Type may be required or recommended.\n\nSee also parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsefeature-Union{Tuple{FT}, Tuple{Type{FT}, String}} where FT<:VarFeature","page":"Home","title":"SoleData.parsefeature","text":"parsefeature(FT::Type{<:VarFeature}, expr::String; kwargs...)\n\nParse a VarFeature of type FT from its syntaxstring representation.\n\nKeyword Arguments\n\nfeatvaltype::Union{Nothing,Type} = nothing: the feature's featvaltype   (recommended for some features, e.g., UnivariateFeature);\nopening_parenthesis::String = \"[\":   the string signaling the opening of an expression block (e.g., \"min[V2]\");\nclosing_parenthesis::String = \"]\":   the string signaling the closing of an expression block (e.g., \"min[V2]\");\nadditional_feature_aliases = Dict{String,Base.Callable}(): A dictionary mapping strings to   callables, useful when parsing custom-made, non-standard features.   By default, features such as \"avg\" or \"min\" are provided for   (see SoleData.BASE_FEATURE_FUNCTIONS_ALIASES);   note that, in case of clashing strings,   the provided additional aliases will override the standard ones;\nvariable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing:   mapping from variable name to variable index, useful when parsing from   syntaxstrings with variable names (e.g., \"min[Heart rate]\");\nvariable_name_prefix::String = \"V\":   prefix used with variable indices (e.g., \"V10\").\n\nNote that at most one argument in variable_names_map and variable_name_prefix should be provided.\n\nnote: Note\nThe default parentheses, here, differ from those of `SoleLogics.parseformula, since features are typically wrapped into Atoms, and parseformula does not allow parenthesis characters in atoms' syntaxstrings.\n\nSee also VarFeature, featvaltype, parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W<:AbstractWorld","page":"Home","title":"SoleData.representatives","text":"representatives(\n    fr::AbstractFrame{W},\n    S::W,\n    ::AbstractRelation,\n    ::AbstractCondition\n) where {W<:AbstractWorld}\n\nReturn an iterator to the (few) representative accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost \"one-step\" optimizations (see AbstractOneStepMemoset).\n\nFor example, consider a Kripke structure with a 1-dimensional FullDimensionalFrame of length 100, and the problem of checking a formula \"⟨L⟩(max[V1] ≥ 10)\" on a SoleLogics.Interval SoleLogics.Interval{Int64}(1, 2) (with L being Allen's \"Later\" relation, see SoleLogics.IA_L). Comparing 10 with the (maximum) \"max[V1]\" computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the \"max[V1]\" computed on the single Interval SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its aggregator).\n\nNote that this method fallsback to accessibles.\n\nSee also SoleLogics.accessibles, ScalarCondition, SoleLogics.AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.scalarlogiset","page":"Home","title":"SoleData.scalarlogiset","text":"scalarlogiset(dataset, features; kwargs...)\n\nConverts a dataset structure (with variables) to a logiset with scalar-valued features. If dataset is not a multimodal dataset, the following methods should be defined: TODO explain\n\n    islogiseed(::typeof(dataset)) = true\n    initlogiset(dataset, features)\n    ninstances(dataset)\n    nvariables(dataset)\n    frame(dataset, i_instance::Integer)\n    featvalue(feature::VarFeature, dataset, i_instance::Integer, w::AbstractWorld)\n    vareltype(dataset, i_variable::Integer)\n\nIf dataset represents a multimodal dataset, the following methods should be defined, while its modalities (iterated via eachmodality) should provide the methods above:\n\n    ismultilogiseed(dataset)\n    nmodalities(dataset)\n    eachmodality(dataset)\n\nSee also AbstractModalLogiset, VarFeature, ScalarCondition.\n\n\n\n\n\n","category":"function"},{"location":"#SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}","page":"Home","title":"SoleData.variable_name","text":"variable_name(\n    f::AbstractUnivariateFeature;\n    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,\n    variable_name_prefix::Union{Nothing,String} = \"V\",\n)::String\n\nReturn the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by \"V\"; however, variable_names_map or variable_name_prefix can be used to customize variable names. The prefix can be customized by specifying variable_name_prefix. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as variable_names_map. Note that only one in variable_names_map and variable_name_prefix should be provided.\n\nSee also parsecondition, ScalarCondition, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleLogics.alphabet","page":"Home","title":"SoleLogics.alphabet","text":"alphabet(X::PropositionalLogiset, sorted=true;\n         test_operators::Union{Nothing,AbstractVector{<:TestOperator},Base.Callable}=nothing,\n         discretizedomain=false, y::Union{Nothing, AbstractVector}=nothing\n)::UnionAlphabet{ScalarCondition,UnivariateScalarAlphabet}\n\nConstructs an alphabet based on the provided PropositionalLogiset X, with optional parameters:\n\nsorted: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)\ntest_operators: test operators to use (defaulted to [≤, ≥] for real-valued features, and [(==), (≠)] for other features, e.g., categorical)\ndiscretizedomain: whether to discretize the domain (default: false)\ny: vector used for discretization (required if discretizedomain is true)\n\nReturns a UnionAlphabet containing ScalarCondition and UnivariateScalarAlphabet.\n\n\n\n\n\n","category":"function"},{"location":"#SoleModels.AbstractModel","page":"Home","title":"SoleModels.AbstractModel","text":"abstract type AbstractModel{O} end\n\nAbstract type for symbolic models that, given an instance object (i.e., a piece of data), output an outcome of type O.\n\nA model is said to be symbolic when its application relies on checking formulas of a certain logical language (see SoleLogics.jl package) on the instance. Symbolic models provide a form of transparent and interpretable modeling, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.\n\nExamples of symbolic models are Rules, Branches, DecisionLists and DecisionTrees. Examples of non-symbolic (or sub-symbolic) models include those encoding algebraic mathematical functions (e.g., neural networks).\n\nSymbolic models can wrap other AbstractModels, and use them to compute the outcome. As such, an AbstractModel can actually be the result of a composition of many models, and enclose a tree of AbstractModels (with LeafModels at the leaves).\n\nSee also LeafModel, Rule, Branch, isopen, apply, info, outcometype.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.Branch","page":"Home","title":"SoleModels.Branch","text":"struct Branch{O} <: AbstractModel{O}\n    antecedent::Formula\n    posconsequent::M where {M<:AbstractModel{<:O}}\n    negconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Branch is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (positive consequent) ELSE (negative consequent) END\n\nwhere the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequenti is applied.\n\nSee also antecedent, posconsequent, negconsequent, SoleLogics.check, SoleLogics.Formula, Rule, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.ConstantModel","page":"Home","title":"SoleModels.ConstantModel","text":"struct ConstantModel{O} <: LeafModel{O}\n    outcome::O\n    info::NamedTuple\nend\n\nThe simplest type of model is the ConstantModel; it is a LeafModel that always outputs the same outcome.\n\nExamples\n\njulia> SoleModels.LeafModel(2) isa SoleModels.ConstantModel\n\njulia> SoleModels.LeafModel(sum) isa SoleModels.FunctionModel\n┌ Warning: Over efficiency concerns, please consider wrappingJulia Function's into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.\n└ @ SoleModels ~/.julia/dev/SoleModels/src/base.jl:337\ntrue\n\n\nSee also apply, FunctionModel, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.DecisionForest","page":"Home","title":"SoleModels.DecisionForest","text":"A Decision Forest is a symbolic model that wraps an ensemble of models\n\nstruct DecisionForest{O} <: AbstractModel{O}\n    trees::Vector{<:DecisionTree}\n    info::NamedTuple\nend\n\nSee also MixedModel, DecisionList, DecisionTree.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.DecisionList","page":"Home","title":"SoleModels.DecisionList","text":"struct DecisionList{O} <: AbstractModel{O}\n    rulebase::Vector{Rule{_O} where {_O<:O}}\n    defaultconsequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA DecisionList (or decision table, or rule-based model) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:\n\nIF (antecedent_1)     THEN (consequent_1)\nELSEIF (antecedent_2) THEN (consequent_2)\n...\nELSEIF (antecedent_n) THEN (consequent_n)\nELSE (consequent_default) END\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.\n\nSee also Rule, DecisionTree, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.DecisionTree","page":"Home","title":"SoleModels.DecisionTree","text":"A DecisionTree is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_2) THEN\n        (consequent_1)\n    ELSE\n        (consequent_2)\n    END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\nIn practice, a DecisionTree simply wraps a constrained sub-tree of Branch and LeafModel:\n\nstruct DecisionTree{O} <: AbstractModel{O}\n    root::M where {M<:AbstractModel}\n    info::NamedTuple\nend\n\nNote that this structure also includes an info::NamedTuple for storing additional information.\n\nSee also MixedModel, DecisionList.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.FunctionModel","page":"Home","title":"SoleModels.FunctionModel","text":"struct FunctionModel{O} <: LeafModel{O}\n    f::FunctionWrapper{O}\n    info::NamedTuple\nend\n\nA FunctionModel is a LeafModel that applies a native Julia Function in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type O by wrapping the Function into an object of type FunctionWrapper{O} (see FunctionWrappers.\n\nSee also ConstantModel, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.LeafModel","page":"Home","title":"SoleModels.LeafModel","text":"abstract type LeafModel{O} <: AbstractModel{O} end\n\nAbstract type for leaf models, that is, models which outcomes do not depend other models, and represents the bottom of the computation. In general, an AbstractModel can generally wrap other AbstractModels; in such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered as a leaf, or final, and is the leaf of a tree of AbstractModels.\n\nSee also ConstantModel, FunctionModel, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.MixedModel","page":"Home","title":"SoleModels.MixedModel","text":"A MixedModel is a symbolic model that operaters as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_1)     THEN (consequent_1)\n    ELSEIF (antecedent_2) THEN (consequent_2)\n    ELSE (consequent_1_default) END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be checked, and the consequents are the feasible local outcomes of the block.\n\nIn Sole.jl, this logic can implemented using AbstractModels such as Rules, Branchs, DecisionLists, DecisionTrees, and the be wrapped into a MixedModel:\n\nstruct MixedModel{O,FM<:AbstractModel} <: AbstractModel{O}\n    root::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also DecisionTree, DecisionList.\n\n\n\n\n\n","category":"type"},{"location":"#SoleModels.Rule","page":"Home","title":"SoleModels.Rule","text":"struct Rule{O} <: AbstractModel{O}\n    antecedent::Formula\n    consequent::M where {M<:AbstractModel{<:O}}\n    info::NamedTuple\nend\n\nA Rule is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (consequent) END\n\nwhere the antecedent is a formula to be checked, and the consequent is the local outcome of the block.\n\nSee also antecedent, consequent, SoleLogics.Formula, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"#Base.isopen-Tuple{SoleModels.AbstractModel}","page":"Home","title":"Base.isopen","text":"isopen(::AbstractModel)::Bool\n\nReturn whether a model is open. An AbstractModel{O} is closed if it is always able to provide an outcome of type O. Otherwise, the model can output nothing values and is referred to as open.\n\nRule is an example of an open model, while Branch is an example of closed model.\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.antecedent-Tuple{Rule}","page":"Home","title":"SoleModels.antecedent","text":"antecedent(m::Union{Rule,Branch})::Formula\n\nReturn the antecedent of a rule/branch, that is, the formula to be checked upon applying the model.\n\nSee also apply, consequent, checkantecedent, Rule, Branch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}","page":"Home","title":"SoleModels.apply","text":"apply(m, i; kwargs...)::outputtype(m)\napply(m, d; kwargs...)::AbstractVector{<:outputtype(m)}\napply(m, d, i_instance; kwargs...)::outputtype(m)\n\nReturn the output prediction of a model m on a logical interpretation i, on the i_instance of a dataset d, or on all instances of a dataset d. Note that predictions can be nothing if the model is open (e.g., if the model is a Rule).\n\nKeyword Arguments\n\ncheck_args::Tuple = ();\ncheck_kwargs::NamedTuple = (;);\nfunctional_args::Tuple = ();\nfunctional_kwargs::NamedTuple = (;);\nAny additional keyword argument is passed down to the model subtree's leaves\n\ncheck_args and check_kwargs can influence check's behavior at the time of its computation (see `SoleLogics.check)\n\nfunctional_args and functional_kwargs can influence FunctionModel's behavior when the corresponding function is applied to AbstractInterpretation (see FunctionModel, `SoleLogics.AbstractInterpretation)\n\nA model state-changing version of the function, [apply!], exist. While producing the output, this function affects the info keys :supporting_labels and :supporting_predictions, which are useful for inspecting the statistical performance of parts of the model.\n\nSee also isopen, readmetrics. AbstractModel, SoleLogics.AbstractInterpretation, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.checkantecedent","page":"Home","title":"SoleModels.checkantecedent","text":"checkantecedent(\n    m::Union{Rule,Branch},\n    args...;\n    kwargs...\n)\n    check(antecedent(m), args...; kwargs...)\nend\n\nSimply check the antecedent of a rule on an instance or dataset.\n\nSee also antecedent, Rule, Branch.\n\n\n\n\n\n","category":"function"},{"location":"#SoleModels.consequent-Tuple{Rule}","page":"Home","title":"SoleModels.consequent","text":"consequent(m::Rule)::AbstractModel\n\nReturn the consequent of a rule.\n\nSee also antecedent, Rule.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.displaymodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprint or returnPa string representation of model m.\n\nArguments\n\nheader::Bool = true: when set to true, a header is printed, displaying the info structure for m;\nshow_subtree_info::Bool = false: when set to true, the header is printed for models in the sub-tree of m;\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the subtree are shown, whenever they are available in the info structure;\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree with a depth higher than max_depth are ellipsed with \"...\";\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for formatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}","page":"Home","title":"SoleModels.evaluaterule","text":"evaluaterule(\n    r::Rule{O},\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{L}\n) where {O,L<:Label}\n\nEvaluate the rule on a labeled dataset, and return a NamedTuple consisting of:\n\nantsat::Vector{Bool}: satsfaction of the antecedent for each instance in the dataset;\nys::Vector{Union{Nothing,O}}: rule prediction. For each instance in X:\nconsequent(rule) if the antecedent is satisfied,\nnothing otherwise.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, checkantecedent.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O","page":"Home","title":"SoleModels.immediatesubmodels","text":"immediatesubmodels(m::AbstractModel)\n\nReturn the list of immediate child models. Note: if the model is a leaf model, then the returned list will be empty.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> immediatesubmodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n SoleModels.ConstantModel{String}\nYES\n\n SoleModels.ConstantModel{String}\nNO\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\n\njulia> printmodel.(immediatesubmodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\n42\n\nSee also submodels, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.info-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.info","text":"info(m::AbstractModel)::NamedTuple = m.info\ninfo(m::AbstractModel, key) = m.info[key]\ninfo(m::AbstractModel, key, defaultval)\n\ninfo!(m::AbstractModel, info::NamedTuple)\ninfo!(m::AbstractModel, key, val)\n\nReturn the info structure for model m; this structure is used for storing additional information that does not affect the model's behavior. This structure can hold, for example, information about the model's statistical performance during the learning phase.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.joinrules","page":"Home","title":"SoleModels.joinrules","text":"joinrules(rules::AbstractVector{<:Rule})::Vector{<:Rule}\n\nReturn a set of rules, with exactly one rule per different outcome from the input set of rules. For each outcome, the output rule is computed as the logical disjunction of the antecedents of the input rules for that outcome.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\njulia> printmodel.(joinrules(listrules(branch)); tree_mode = true);\n▣ (p ∧ q)\n└✔ YES\n\n▣ (p ∧ ¬q) ∨ ¬p\n└✔ NO\n\n\nSee also listrules, SoleLogics.DISJUNCTION, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.listimmediaterules","text":"listimmediaterules(m::AbstractModel{O} where {O})::Rule{<:O}\n\nList the immediate rules equivalent to a symbolic model.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listimmediaterules(branch); tree_mode = true);\n▣ p\n└✔ q\n ├✔ YES\n └✘ NO\n\n▣ ¬(p)\n└✔ NO\n\n\n\nSee also listrules, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.listrules-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.listrules","text":"listrules(\n    m::AbstractModel;\n    use_shortforms::Bool = true,\n    use_leftmostlinearform::Union{Nothing,Bool} = nothing,\n    normalize::Bool = false,\n    force_syntaxtree::Bool = false,\n)::Vector{<:Rule}\n\nReturn a list of rules capturing the knowledge enclosed in symbolic model. The behavior of any symbolic model can be synthesised and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.\n\nThe keyword argument force_syntaxtree, when set to true, causes the logical antecedents in the returned rules to be represented as SyntaxTrees, as opposed to other syntax structure (e.g., LeftmostConjunctiveForm).\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\n\nSee also listimmediaterules, SoleLogics.CONJUNCTION, joinrules, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.negconsequent-Tuple{Branch}","page":"Home","title":"SoleModels.negconsequent","text":"negconsequent(m::Branch)::AbstractModel\n\nReturn the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to false.\n\nSee also antecedent, Branch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.outcometype-Union{Tuple{Type{<:SoleModels.AbstractModel{O}}}, Tuple{O}} where O","page":"Home","title":"SoleModels.outcometype","text":"outcometype(::Type{<:AbstractModel{O}}) where {O} = O\noutcometype(m::AbstractModel) = outcometype(typeof(m))\n\nReturn the outcome type of a model (type).\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.outputtype","text":"outputtype(m::AbstractModel)\n\nReturn a supertype for the outputs obtained when applying a model. The result depends on whether the model is open or closed:\n\noutputtype(M::AbstractModel{O}) = isopen(M) ? Union{Nothing,O} : O\n\nNote that if the model is closed, then outputtype(m) is equal to outcometype(m).\n\nSee also isopen, apply, outcometype, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.parse_orange_decision_list","page":"Home","title":"SoleModels.parse_orange_decision_list","text":"parse_orange_decision_list(decision_list, ignoredefaultrule = false; featuretype = SoleData.VariableValue)\n\nParser for orange-style decision lists. Reference: https://orange3.readthedocs.io/projects/orange-visual-programming/en/latest/widgets/model/cn2ruleinduction.html\n\nArguments\n\ndecision_list is an AbstractString containing the orange-style representation of a decision list;\nignoredefaultrule is an optional, Boolean parameter indicating whether to use the default rule   as the default rule for the resulting decision list.   When false, the last rule is ignored, and the second last is used as the default rule;\nfeaturetype specifies the feature type used in the parsed ScalarConditions.\n\nExamples\n\njulia> dl = \"\n[49, 0, 0] IF petal length<=3.0 AND sepal width>=2.9 THEN iris=Iris-setosa  -0.0\n[0, 0, 39] IF petal width>=1.8 AND sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[0, 8, 0] IF sepal length>=4.9 AND sepal width>=3.1 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF petal length<=4.9 AND petal width>=1.7 THEN iris=Iris-virginica  -0.0\n[0, 0, 5] IF petal width>=1.8 THEN iris=Iris-virginica  -0.0\n[0, 35, 0] IF petal length<=5.0 AND sepal width>=2.4 THEN iris=Iris-versicolor  -0.0\n[0, 0, 2] IF sepal width>=2.8 THEN iris=Iris-virginica  -0.0\n[0, 3, 0] IF petal width<=1.0 AND sepal length>=5.0 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal width>=2.7 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal width>=2.6 THEN iris=Iris-virginica  -0.0\n[0, 2, 0] IF sepal length>=5.5 AND sepal length>=6.2 THEN iris=Iris-versicolor  -0.0\n[0, 1, 0] IF sepal length<=5.5 AND petal length>=4.0 THEN iris=Iris-versicolor  -0.0\n[0, 0, 1] IF sepal length>=6.0 THEN iris=Iris-virginica  -0.0\n[1, 0, 0] IF sepal length<=4.5 THEN iris=Iris-setosa  -0.0\n[50, 50, 50] IF TRUE THEN iris=Iris-setosa  -1.584962500721156\n\" |> SoleModels.parse_orange_decision_list\n\njulia> listrules(dl; normalize = true)\n15-element Vector{ClassificationRule{String}}:\n ▣ ((:petal_length ≤ 3.0) ∧ (:sepal_width ≥ 2.9))  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width ≥ 1.8) ∧ (:sepal_length ≥ 6.0))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length ≥ 4.9) ∧ (:sepal_width ≥ 3.1))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length ≤ 4.9) ∧ (:petal_width ≥ 1.7))  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width ≥ 1.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length ≤ 5.0) ∧ (:sepal_width ≥ 2.4))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width ≥ 2.8)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width ≤ 1.0) ∧ (:sepal_length ≥ 5.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width ≥ 2.7)  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width ≥ 2.6)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length ≥ 5.5) ∧ (:sepal_length ≥ 6.2))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length ≤ 5.5) ∧ (:petal_length ≥ 4.0))  ↣  Iris-versicolor\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length ≥ 6.0)  ↣  Iris-virginica\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length ≤ 4.5)  ↣  Iris-setosa\n\n ▣ ((:petal_length > 3.0) ∨ (:sepal_width < 2.9)) ∧ ((:petal_width < 1.8) ∨ (:sepal_length < 6.0)) ∧ ((:sepal_length < 4.9) ∨ (:sepal_width < 3.1)) ∧ ((:petal_length > 4.9) ∨ (:petal_width < 1.7)) ∧ (:petal_width < 1.8) ∧ ((:petal_length > 5.0) ∨ (:sepal_width < 2.4)) ∧ (:sepal_width < 2.8) ∧ ((:petal_width > 1.0) ∨ (:sepal_length < 5.0)) ∧ (:sepal_width < 2.7) ∧ (:sepal_width < 2.6) ∧ ((:sepal_length < 5.5) ∨ (:sepal_length < 6.2)) ∧ ((:sepal_length > 5.5) ∨ (:petal_length < 4.0)) ∧ (:sepal_length < 6.0) ∧ (:sepal_length > 4.5)  ↣  Iris-setosa\n\n\nSee also DecisionList.\n\n\n\n\n\n","category":"function"},{"location":"#SoleModels.posconsequent-Tuple{Branch}","page":"Home","title":"SoleModels.posconsequent","text":"posconsequent(m::Branch)::AbstractModel\n\nReturn the positive consequent of a branch; that is, the model to be applied if the antecedent evaluates to true.\n\nSee also antecedent, Branch.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.printmodel-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.printmodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprint or returnPa string representation of model m.\n\nArguments\n\nheader::Bool = true: when set to true, a header is printed, displaying the info structure for m;\nshow_subtree_info::Bool = false: when set to true, the header is printed for models in the sub-tree of m;\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the subtree are shown, whenever they are available in the info structure;\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree with a depth higher than max_depth are ellipsed with \"...\";\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for formatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}","page":"Home","title":"SoleModels.readmetrics","text":"readmetrics(m::AbstractModel; round_digits = nothing)\n\nReturn a NamedTuple with some performance metrics for the given symbolic model. Performance metrics can be computed when the info structure of the model has the     following keys:     - :supportinglabels     - :supportingpredictions\n\nThe round_digits keyword argument, if provided, is used to round accuracy/confidence metrics.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}","page":"Home","title":"SoleModels.rulemetrics","text":"rulemetrics(\n    r::Rule,\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{<:Label}\n)\n\nCompute metrics for a rule with respect to a labeled dataset and returns a NamedTuple consisting of:\n\nsupport: number of instances satisfying the antecedent of the rule divided by   the total number of instances;\nerror:\nFor classification problems: number of instances that were not classified\ncorrectly divided by the total number of instances;\nFor regression problems: mean squared error;\nlength: number of atoms in the rule's antecedent.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, evaluaterule, outcometype, consequent.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.submodels-Tuple{SoleModels.AbstractModel}","page":"Home","title":"SoleModels.submodels","text":"submodels(m::AbstractModel)\n\nEnumerate all submodels in the sub-tree. This function is the transitive closure of immediatesubmodels; in fact, the returned list includes the immediate submodels (immediatesubmodels(m)), but also their immediate submodels, and so on.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> submodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n ConstantModel\nYES\n\n ConstantModel\nNO\n\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\njulia> printmodel.(submodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\nYES\n\nConstantModel\nNO\n\nConstantModel\n42\n\njulia> submodels(branch) == immediatesubmodels(branch)\ntrue\n\njulia> submodels(branch2) == immediatesubmodels(branch2)\nfalse\n\nSee also immediatesubmodels, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"#SoleModels.wrap-Tuple{Any, Type{<:SoleModels.AbstractModel}}","page":"Home","title":"SoleModels.wrap","text":"wrap(o::Any)::AbstractModel\n\nThis function wraps anything into an AbstractModel. The default behavior is the following:\n\nwhen called on an AbstractModel, the model is\n\nsimply returned (no wrapping is performed);\n\nFunctions and FunctionWrappers are wrapped into a FunctionModel;\nevery other object is wrapped into a ConstantModel.\n\nSee also ConstantModel, FunctionModel, LeafModel.\n\n\n\n\n\n","category":"method"}]
}
